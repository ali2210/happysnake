{"ast":null,"code":"import _slicedToArray from \"/home/ali/Documents/run_prj/happysnake/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/home/ali/Documents/run_prj/happysnake/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/ali/Documents/run_prj/happysnake/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/ali/Documents/run_prj/happysnake/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/ali/Documents/run_prj/happysnake/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/ali/Documents/run_prj/happysnake/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _wrapNativeSuper from \"/home/ali/Documents/run_prj/happysnake/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\nimport _toArray from \"/home/ali/Documents/run_prj/happysnake/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toArray\";\nimport _toConsumableArray from \"/home/ali/Documents/run_prj/happysnake/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction decode_arithmetic(bytes) {\n  var pos = 0;\n  function u16() {\n    return bytes[pos++] << 8 | bytes[pos++];\n  }\n\n  // decode the frequency table\n  var symbol_count = u16();\n  var total = 1;\n  var acc = [0, 1]; // first symbol has frequency 1\n  for (var i = 1; i < symbol_count; i++) {\n    acc.push(total += u16());\n  }\n\n  // skip the sized-payload that the last 3 symbols index into\n  var skip = u16();\n  var pos_payload = pos;\n  pos += skip;\n  var read_width = 0;\n  var read_buffer = 0;\n  function read_bit() {\n    if (read_width == 0) {\n      // this will read beyond end of buffer\n      // but (undefined|0) => zero pad\n      read_buffer = read_buffer << 8 | bytes[pos++];\n      read_width = 8;\n    }\n    return read_buffer >> --read_width & 1;\n  }\n  var N = 31;\n  var FULL = Math.pow(2, N);\n  var HALF = FULL >>> 1;\n  var QRTR = HALF >> 1;\n  var MASK = FULL - 1;\n\n  // fill register\n  var register = 0;\n  for (var _i = 0; _i < N; _i++) register = register << 1 | read_bit();\n  var symbols = [];\n  var low = 0;\n  var range = FULL; // treat like a float\n  while (true) {\n    var value = Math.floor(((register - low + 1) * total - 1) / range);\n    var start = 0;\n    var end = symbol_count;\n    while (end - start > 1) {\n      // binary search\n      var mid = start + end >>> 1;\n      if (value < acc[mid]) {\n        end = mid;\n      } else {\n        start = mid;\n      }\n    }\n    if (start == 0) break; // first symbol is end mark\n    symbols.push(start);\n    var a = low + Math.floor(range * acc[start] / total);\n    var b = low + Math.floor(range * acc[start + 1] / total) - 1;\n    while (((a ^ b) & HALF) == 0) {\n      register = register << 1 & MASK | read_bit();\n      a = a << 1 & MASK;\n      b = b << 1 & MASK | 1;\n    }\n    while (a & ~b & QRTR) {\n      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();\n      a = a << 1 ^ HALF;\n      b = (b ^ HALF) << 1 | HALF | 1;\n    }\n    low = a;\n    range = 1 + b - a;\n  }\n  var offset = symbol_count - 4;\n  return symbols.map(function (x) {\n    // index into payload\n    switch (x - offset) {\n      case 3:\n        return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n      case 2:\n        return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n      case 1:\n        return offset + bytes[pos_payload++];\n      default:\n        return x - 1;\n    }\n  });\n}\n\n// returns an iterator which returns the next symbol\nfunction read_payload(v) {\n  var pos = 0;\n  return function () {\n    return v[pos++];\n  };\n}\nfunction read_compressed_payload(s) {\n  return read_payload(decode_arithmetic(unsafe_atob(s)));\n}\n\n// unsafe in the sense:\n// expected well-formed Base64 w/o padding \nfunction unsafe_atob(s) {\n  var lookup = [];\n  _toConsumableArray('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/').forEach(function (c, i) {\n    return lookup[c.charCodeAt(0)] = i;\n  });\n  var n = s.length;\n  var ret = new Uint8Array(6 * n >> 3);\n  for (var i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {\n    carry = carry << 6 | lookup[s.charCodeAt(i)];\n    width += 6;\n    if (width >= 8) {\n      ret[pos++] = carry >> (width -= 8);\n    }\n  }\n  return ret;\n}\n\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nfunction signed(i) {\n  return i & 1 ? ~i >> 1 : i >> 1;\n}\nfunction read_deltas(n, next) {\n  var v = Array(n);\n  for (var i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\n  return v;\n}\n\n// [123][5] => [0 3] [1 1] [0 0]\nfunction read_sorted(next) {\n  var prev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var ret = [];\n  while (true) {\n    var x = next();\n    var n = next();\n    if (!n) break;\n    prev += x;\n    for (var i = 0; i < n; i++) {\n      ret.push(prev + i);\n    }\n    prev += n + 1;\n  }\n  return ret;\n}\nfunction read_sorted_arrays(next) {\n  return read_array_while(function () {\n    var v = read_sorted(next);\n    if (v.length) return v;\n  });\n}\n\n// returns map of x => ys\nfunction read_mapped(next) {\n  var ret = [];\n  while (true) {\n    var w = next();\n    if (w == 0) break;\n    ret.push(read_linear_table(w, next));\n  }\n  while (true) {\n    var _w = next() - 1;\n    if (_w < 0) break;\n    ret.push(read_replacement_table(_w, next));\n  }\n  return ret.flat();\n}\n\n// read until next is falsy\n// return array of read values\nfunction read_array_while(next) {\n  var v = [];\n  while (true) {\n    var x = next(v.length);\n    if (!x) break;\n    v.push(x);\n  }\n  return v;\n}\n\n// read w columns of length n\n// return as n rows of length w\nfunction read_transposed(n, w, next) {\n  var m = Array(n).fill().map(function () {\n    return [];\n  });\n  for (var i = 0; i < w; i++) {\n    read_deltas(n, next).forEach(function (x, j) {\n      return m[j].push(x);\n    });\n  }\n  return m;\n}\n\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\n// where dx/dy = steps, n = run size, w = length of y\nfunction read_linear_table(w, next) {\n  var dx = 1 + next();\n  var dy = next();\n  var vN = read_array_while(next);\n  var m = read_transposed(vN.length, 1 + w, next);\n  return m.flatMap(function (v, i) {\n    var _v = _toArray(v),\n      x = _v[0],\n      ys = _v.slice(1);\n    return Array(vN[i]).fill().map(function (_, j) {\n      var j_dy = j * dy;\n      return [x + j * dx, ys.map(function (y) {\n        return y + j_dy;\n      })];\n    });\n  });\n}\n\n// return [[x, ys...], ...]\n// where w = length of y\nfunction read_replacement_table(w, next) {\n  var n = 1 + next();\n  var m = read_transposed(n, 1 + w, next);\n  return m.map(function (v) {\n    return [v[0], v.slice(1)];\n  });\n}\n\n// created 2023-02-21T09:18:13.549Z\nvar r$1 = read_compressed_payload('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');\nvar FENCED = new Map([[8217, \"apostrophe\"], [8260, \"fraction slash\"], [12539, \"middle dot\"]]);\nvar NSM_MAX = 4;\nfunction hex_cp(cp) {\n  return cp.toString(16).toUpperCase().padStart(2, '0');\n}\nfunction quote_cp(cp) {\n  return \"{\".concat(hex_cp(cp), \"}\"); // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\n}\n\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/\nfunction explode_cp(s) {\n  // this is about 2x faster\n  var cps = [];\n  for (var pos = 0, len = s.length; pos < len;) {\n    var cp = s.codePointAt(pos);\n    pos += cp < 0x10000 ? 1 : 2;\n    cps.push(cp);\n  }\n  return cps;\n}\nfunction str_from_cps(cps) {\n  var chunk = 4096;\n  var len = cps.length;\n  if (len < chunk) return String.fromCodePoint.apply(String, _toConsumableArray(cps));\n  var buf = [];\n  for (var i = 0; i < len;) {\n    buf.push(String.fromCodePoint.apply(String, _toConsumableArray(cps.slice(i, i += chunk))));\n  }\n  return buf.join('');\n}\nfunction compare_arrays(a, b) {\n  var n = a.length;\n  var c = n - b.length;\n  for (var i = 0; c == 0 && i < n; i++) c = a[i] - b[i];\n  return c;\n}\n\n// created 2023-02-21T09:18:13.549Z\nvar r = read_compressed_payload('AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g');\n\n// https://unicode.org/reports/tr15/\n\nfunction unpack_cc(packed) {\n  return packed >> 24 & 0xFF;\n}\nfunction unpack_cp(packed) {\n  return packed & 0xFFFFFF;\n}\nvar SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap(function (v, i) {\n  return v.map(function (x) {\n    return [x, i + 1 << 24];\n  });\n})); // pre-shifted\nvar EXCLUSIONS = new Set(read_sorted(r));\nvar DECOMP = new Map();\nvar RECOMP = new Map();\nvar _iterator = _createForOfIteratorHelper(read_mapped(r)),\n  _step;\ntry {\n  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n    var _step$value = _slicedToArray(_step.value, 2),\n      cp = _step$value[0],\n      cps = _step$value[1];\n    if (!EXCLUSIONS.has(cp) && cps.length == 2) {\n      var _cps3 = _slicedToArray(cps, 2),\n        a = _cps3[0],\n        b = _cps3[1];\n      var bucket = RECOMP.get(a);\n      if (!bucket) {\n        bucket = new Map();\n        RECOMP.set(a, bucket);\n      }\n      bucket.set(b, cp);\n    }\n    DECOMP.set(cp, cps.reverse()); // stored reversed\n  }\n\n  // algorithmic hangul\n  // https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\n} catch (err) {\n  _iterator.e(err);\n} finally {\n  _iterator.f();\n}\nvar S0 = 0xAC00;\nvar L0 = 0x1100;\nvar V0 = 0x1161;\nvar T0 = 0x11A7;\nvar L_COUNT = 19;\nvar V_COUNT = 21;\nvar T_COUNT = 28;\nvar N_COUNT = V_COUNT * T_COUNT;\nvar S_COUNT = L_COUNT * N_COUNT;\nvar S1 = S0 + S_COUNT;\nvar L1 = L0 + L_COUNT;\nvar V1 = V0 + V_COUNT;\nvar T1 = T0 + T_COUNT;\nfunction is_hangul(cp) {\n  return cp >= S0 && cp < S1;\n}\nfunction compose_pair(a, b) {\n  if (a >= L0 && a < L1 && b >= V0 && b < V1) {\n    return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\n  } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\n    return a + (b - T0);\n  } else {\n    var recomp = RECOMP.get(a);\n    if (recomp) {\n      recomp = recomp.get(b);\n      if (recomp) {\n        return recomp;\n      }\n    }\n    return -1;\n  }\n}\nfunction decomposed(cps) {\n  var ret = [];\n  var buf = [];\n  var check_order = false;\n  function add(cp) {\n    var cc = SHIFTED_RANK.get(cp);\n    if (cc) {\n      check_order = true;\n      cp |= cc;\n    }\n    ret.push(cp);\n  }\n  var _iterator2 = _createForOfIteratorHelper(cps),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var cp = _step2.value;\n      while (true) {\n        if (cp < 0x80) {\n          ret.push(cp);\n        } else if (is_hangul(cp)) {\n          var s_index = cp - S0;\n          var l_index = s_index / N_COUNT | 0;\n          var v_index = s_index % N_COUNT / T_COUNT | 0;\n          var t_index = s_index % T_COUNT;\n          add(L0 + l_index);\n          add(V0 + v_index);\n          if (t_index > 0) add(T0 + t_index);\n        } else {\n          var mapped = DECOMP.get(cp);\n          if (mapped) {\n            buf.push.apply(buf, _toConsumableArray(mapped));\n          } else {\n            add(cp);\n          }\n        }\n        if (!buf.length) break;\n        cp = buf.pop();\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  if (check_order && ret.length > 1) {\n    var prev_cc = unpack_cc(ret[0]);\n    for (var i = 1; i < ret.length; i++) {\n      var cc = unpack_cc(ret[i]);\n      if (cc == 0 || prev_cc <= cc) {\n        prev_cc = cc;\n        continue;\n      }\n      var j = i - 1;\n      while (true) {\n        var tmp = ret[j + 1];\n        ret[j + 1] = ret[j];\n        ret[j] = tmp;\n        if (!j) break;\n        prev_cc = unpack_cc(ret[--j]);\n        if (prev_cc <= cc) break;\n      }\n      prev_cc = unpack_cc(ret[i]);\n    }\n  }\n  return ret;\n}\nfunction composed_from_decomposed(v) {\n  var ret = [];\n  var stack = [];\n  var prev_cp = -1;\n  var prev_cc = 0;\n  var _iterator3 = _createForOfIteratorHelper(v),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var packed = _step3.value;\n      var cc = unpack_cc(packed);\n      var cp = unpack_cp(packed);\n      if (prev_cp == -1) {\n        if (cc == 0) {\n          prev_cp = cp;\n        } else {\n          ret.push(cp);\n        }\n      } else if (prev_cc > 0 && prev_cc >= cc) {\n        if (cc == 0) {\n          ret.push.apply(ret, [prev_cp].concat(stack));\n          stack.length = 0;\n          prev_cp = cp;\n        } else {\n          stack.push(cp);\n        }\n        prev_cc = cc;\n      } else {\n        var composed = compose_pair(prev_cp, cp);\n        if (composed >= 0) {\n          prev_cp = composed;\n        } else if (prev_cc == 0 && cc == 0) {\n          ret.push(prev_cp);\n          prev_cp = cp;\n        } else {\n          stack.push(cp);\n          prev_cc = cc;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  if (prev_cp >= 0) {\n    ret.push.apply(ret, [prev_cp].concat(stack));\n  }\n  return ret;\n}\n\n// note: cps can be iterable\nfunction nfd(cps) {\n  return decomposed(cps).map(unpack_cp);\n}\nfunction nfc(cps) {\n  return composed_from_decomposed(decomposed(cps));\n}\n\n//const t0 = performance.now();\n\nvar STOP = 0x2E;\nvar FE0F = 0xFE0F;\nvar STOP_CH = '.';\nvar UNIQUE_PH = 1;\nvar HYPHEN = 0x2D;\nfunction read_set() {\n  return new Set(read_sorted(r$1));\n}\nvar MAPPED = new Map(read_mapped(r$1));\nvar IGNORED = read_set(); // ignored characters are not valid, so just read raw codepoints\n/*\r\n// direct include from payload is smaller that the decompression code\r\nconst FENCED = new Map(read_array_while(() => {\r\n\tlet cp = r();\r\n\tif (cp) return [cp, read_str(r())];\r\n}));\r\n*/\n// 20230217: we still need all CM for proper error formatting\n// but norm only needs NSM subset that are potentially-valid\nvar CM = read_set();\nvar NSM = new Set(read_sorted(r$1).map(function (i) {\n  return this[i];\n}, _toConsumableArray(CM)));\n/*\r\nconst CM_SORTED = read_sorted(r);\r\nconst NSM = new Set(read_sorted(r).map(i => CM_SORTED[i]));\r\nconst CM = new Set(CM_SORTED);\r\n*/\nvar ESCAPE = read_set(); // characters that should not be printed\nvar NFC_CHECK = read_set();\nvar CHUNKS = read_sorted_arrays(r$1);\nfunction read_chunked() {\n  // deduplicated sets + uniques\n  return new Set([read_sorted(r$1).map(function (i) {\n    return CHUNKS[i];\n  }), read_sorted(r$1)].flat(2));\n}\nvar UNRESTRICTED = r$1();\nvar GROUPS = read_array_while(function (i) {\n  // minifier property mangling seems unsafe\n  // so these are manually renamed to single chars\n  var N = read_array_while(r$1).map(function (x) {\n    return x + 0x60;\n  });\n  if (N.length) {\n    var R = i >= UNRESTRICTED; // first arent restricted\n    N[0] -= 32; // capitalize\n    N = str_from_cps(N);\n    if (R) N = \"Restricted[\".concat(N, \"]\");\n    var P = read_chunked(); // primary\n    var Q = read_chunked(); // secondary\n    var V = [].concat(_toConsumableArray(P), _toConsumableArray(Q)).sort(function (a, b) {\n      return a - b;\n    }); // derive: sorted valid\n    //let M = r()-1; // combining mark\n    var M = !r$1(); // not-whitelisted, check for NSM\n    // code currently isn't needed\n    /*if (M < 0) { // whitelisted\r\n    \tM = new Map(read_array_while(() => {\r\n    \t\tlet i = r();\r\n    \t\tif (i) return [V[i-1], read_array_while(() => {\r\n    \t\t\tlet v = read_array_while(r);\r\n    \t\t\tif (v.length) return v.map(x => x-1);\r\n    \t\t})];\r\n    \t}));\r\n    }*/\n    return {\n      N: N,\n      P: P,\n      M: M,\n      R: R,\n      V: new Set(V)\n    };\n  }\n});\nvar WHOLE_VALID = read_set();\nvar WHOLE_MAP = new Map();\n// decode compressed wholes\n[].concat(_toConsumableArray(WHOLE_VALID), _toConsumableArray(read_set())).sort(function (a, b) {\n  return a - b;\n}).map(function (cp, i, v) {\n  var d = r$1();\n  var w = v[i] = d ? v[i - d] : {\n    V: [],\n    M: new Map()\n  };\n  w.V.push(cp); // add to member set\n  if (!WHOLE_VALID.has(cp)) {\n    WHOLE_MAP.set(cp, w); // register with whole map\n  }\n});\n// compute confusable-extent complements\nvar _iterator4 = _createForOfIteratorHelper(new Set(WHOLE_MAP.values())),\n  _step4;\ntry {\n  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n    var _step4$value = _step4.value,\n      V = _step4$value.V,\n      M = _step4$value.M;\n    // connect all groups that have each whole character\n    var recs = [];\n    var _iterator14 = _createForOfIteratorHelper(V),\n      _step14;\n    try {\n      var _loop6 = function _loop6() {\n        var cp = _step14.value;\n        var gs = GROUPS.filter(function (g) {\n          return g.V.has(cp);\n        });\n        var rec = recs.find(function (_ref4) {\n          var G = _ref4.G;\n          return gs.some(function (g) {\n            return G.has(g);\n          });\n        });\n        if (!rec) {\n          rec = {\n            G: new Set(),\n            V: []\n          };\n          recs.push(rec);\n        }\n        rec.V.push(cp);\n        gs.forEach(function (g) {\n          return rec.G.add(g);\n        });\n      };\n      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n        _loop6();\n      }\n      // per character cache groups which are not a member of the extent\n    } catch (err) {\n      _iterator14.e(err);\n    } finally {\n      _iterator14.f();\n    }\n    var _union = recs.flatMap(function (_ref3) {\n      var G = _ref3.G;\n      return _toConsumableArray(G);\n    });\n    var _loop5 = function _loop5() {\n      var _recs$_i = _recs[_i2],\n        G = _recs$_i.G,\n        V = _recs$_i.V;\n      var complement = new Set(_union.filter(function (g) {\n        return !G.has(g);\n      }));\n      var _iterator15 = _createForOfIteratorHelper(V),\n        _step15;\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var _cp2 = _step15.value;\n          M.set(_cp2, complement);\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n    };\n    for (var _i2 = 0, _recs = recs; _i2 < _recs.length; _i2++) {\n      _loop5();\n    }\n  }\n} catch (err) {\n  _iterator4.e(err);\n} finally {\n  _iterator4.f();\n}\nvar union = new Set(); // exists in 1+ groups\nvar multi = new Set(); // exists in 2+ groups\nvar _iterator5 = _createForOfIteratorHelper(GROUPS),\n  _step5;\ntry {\n  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n    var g = _step5.value;\n    var _iterator16 = _createForOfIteratorHelper(g.V),\n      _step16;\n    try {\n      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n        var _cp3 = _step16.value;\n        (union.has(_cp3) ? multi : union).add(_cp3);\n      }\n    } catch (err) {\n      _iterator16.e(err);\n    } finally {\n      _iterator16.f();\n    }\n  }\n  // dual purpose WHOLE_MAP: return placeholder if unique non-confusable\n} catch (err) {\n  _iterator5.e(err);\n} finally {\n  _iterator5.f();\n}\nvar _iterator6 = _createForOfIteratorHelper(union),\n  _step6;\ntry {\n  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n    var _cp4 = _step6.value;\n    if (!WHOLE_MAP.has(_cp4) && !multi.has(_cp4)) {\n      WHOLE_MAP.set(_cp4, UNIQUE_PH);\n    }\n  }\n} catch (err) {\n  _iterator6.e(err);\n} finally {\n  _iterator6.f();\n}\nvar VALID = new Set([].concat(_toConsumableArray(union), _toConsumableArray(nfd(union)))); // possibly valid\n\n// decode emoji\nvar EMOJI_SORTED = read_sorted(r$1); // temporary\n//const EMOJI_SOLO = new Set(read_sorted(r).map(i => EMOJI_SORTED[i])); // not needed\nvar EMOJI_ROOT = read_emoji_trie([]);\nfunction read_emoji_trie(cps) {\n  var B = read_array_while(function () {\n    var keys = read_sorted(r$1).map(function (i) {\n      return EMOJI_SORTED[i];\n    });\n    if (keys.length) return read_emoji_trie(keys);\n  }).sort(function (a, b) {\n    return b.Q.size - a.Q.size;\n  }); // sort by likelihood\n  var temp = r$1();\n  var V = temp % 3; // valid (0 = false, 1 = true, 2 = weird)\n  temp = temp / 3 | 0;\n  var F = temp & 1; // allow FE0F\n  temp >>= 1;\n  var S = temp & 1; // save\n  var C = temp & 2; // check\n  return {\n    B: B,\n    V: V,\n    F: F,\n    S: S,\n    C: C,\n    Q: new Set(cps)\n  };\n}\n//console.log(performance.now() - t0);\n\n// free tagging system\nvar Emoji = /*#__PURE__*/function (_Array) {\n  _inherits(Emoji, _Array);\n  function Emoji() {\n    _classCallCheck(this, Emoji);\n    return _possibleConstructorReturn(this, _getPrototypeOf(Emoji).apply(this, arguments));\n  }\n  _createClass(Emoji, [{\n    key: \"is_emoji\",\n    get: function get() {\n      return true;\n    }\n  }]);\n  return Emoji;\n}(_wrapNativeSuper(Array)); // create a safe to print string \n// invisibles are escaped\n// leading cm uses placeholder\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\n// note: in html, you'd call this function then replace [<>&] with entities\nfunction safe_str_from_cps(cps) {\n  var quoter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : quote_cp;\n  //if (Number.isInteger(cps)) cps = [cps];\n  //if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\n  var buf = [];\n  if (is_combining_mark(cps[0])) buf.push('◌');\n  var prev = 0;\n  var n = cps.length;\n  for (var i = 0; i < n; i++) {\n    var cp = cps[i];\n    if (should_escape(cp)) {\n      buf.push(str_from_cps(cps.slice(prev, i)));\n      buf.push(quoter(cp));\n      prev = i + 1;\n    }\n  }\n  buf.push(str_from_cps(cps.slice(prev, n)));\n  return buf.join('');\n}\n\n// if escaped: {HEX}\n//       else: \"x\" {HEX}\nfunction quoted_cp(cp) {\n  return (should_escape(cp) ? '' : \"\".concat(bidi_qq(safe_str_from_cps([cp])), \" \")) + quote_cp(cp);\n}\n\n// 20230211: some messages can be mixed-directional and result in spillover\n// use 200E after a quoted string to force the remainder of a string from \n// acquring the direction of the quote\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\nfunction bidi_qq(s) {\n  return \"\\\"\".concat(s, \"\\\"\\u200E\"); // strong LTR\n}\n\nfunction check_label_extension(cps) {\n  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\n    throw new Error('invalid label extension');\n  }\n}\nfunction check_leading_underscore(cps) {\n  var UNDERSCORE = 0x5F;\n  for (var i = cps.lastIndexOf(UNDERSCORE); i > 0;) {\n    if (cps[--i] !== UNDERSCORE) {\n      throw new Error('underscore allowed only at start');\n    }\n  }\n}\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\nfunction check_fenced(cps) {\n  var cp = cps[0];\n  var prev = FENCED.get(cp);\n  if (prev) throw error_placement(\"leading \".concat(prev));\n  var n = cps.length;\n  var last = -1; // prevents trailing from throwing\n  for (var i = 1; i < n; i++) {\n    cp = cps[i];\n    var match = FENCED.get(cp);\n    if (match) {\n      // since cps[0] isn't fenced, cps[1] cannot throw\n      if (last == i) throw error_placement(\"\".concat(prev, \" + \").concat(match));\n      last = i + 1;\n      prev = match;\n    }\n  }\n  if (last == n) throw error_placement(\"trailing \".concat(prev));\n}\n\n// note: set(s) cannot be exposed because they can be modified\nfunction is_combining_mark(cp) {\n  return CM.has(cp);\n}\nfunction should_escape(cp) {\n  return ESCAPE.has(cp);\n}\nfunction ens_normalize_fragment(frag, decompose) {\n  var nf = decompose ? nfd : nfc;\n  return frag.split(STOP_CH).map(function (label) {\n    return str_from_cps(process(explode_cp(label), nf).flatMap(function (x) {\n      return x.is_emoji ? filter_fe0f(x) : x;\n    }));\n  }).join(STOP_CH);\n}\nfunction ens_normalize(name) {\n  return flatten(ens_split(name));\n}\nfunction ens_beautify(name) {\n  var split = ens_split(name, true);\n  // this is experimental\n  var _iterator7 = _createForOfIteratorHelper(split),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var _step7$value = _step7.value,\n        type = _step7$value.type,\n        output = _step7$value.output,\n        error = _step7$value.error;\n      if (error) continue;\n\n      // replace leading/trailing hyphen\n      // 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\n      // not exactly the same in every font, but very similar: \"-\" vs \"‐\"\n      /*\r\n      const UNICODE_HYPHEN = 0x2010;\r\n      // maybe this should replace all for visual consistancy?\r\n      // `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n      //for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n      if (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n      let end = output.length-1;\r\n      if (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n      */\n      // 20230123: WHATWG URL uses \"CheckHyphens\" false\n      // https://url.spec.whatwg.org/#idna\n\n      // update ethereum symbol\n      // ξ => Ξ if not greek\n      if (type !== 'Greek') {\n        var prev = 0;\n        while (true) {\n          var next = output.indexOf(0x3BE, prev);\n          if (next < 0) break;\n          output[next] = 0x39E;\n          prev = next + 1;\n        }\n      }\n\n      // 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\n      // could be fixed with special case for: 2D (.) + 200E (LTR)\n      //output.splice(0, 0, 0x200E);\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  return flatten(split);\n}\nfunction ens_split(name, preserve_emoji) {\n  var offset = 0;\n  // https://unicode.org/reports/tr46/#Validity_Criteria\n  // 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\n  return name.split(STOP_CH).map(function (label) {\n    var input = explode_cp(label);\n    var info = {\n      input: input,\n      offset: offset // codepoint, not substring!\n    };\n\n    offset += input.length + 1; // + stop\n    var norm;\n    try {\n      // 1.) \"The label must be in Unicode Normalization Form NFC\"\n      var tokens = info.tokens = process(input, nfc); // if we parse, we get [norm and mapped]\n      var token_count = tokens.length;\n      var type;\n      if (!token_count) {\n        // the label was effectively empty (could of had ignored characters)\n        // 20230120: change to strict\n        // https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\n        //norm = [];\n        //type = 'None'; // use this instead of next match, \"ASCII\"\n        throw new Error(\"empty label\");\n      } else {\n        var chars = tokens[0];\n        var emoji = token_count > 1 || chars.is_emoji;\n        if (!emoji && chars.every(function (cp) {\n          return cp < 0x80;\n        })) {\n          // special case for ascii\n          norm = chars;\n          check_leading_underscore(norm);\n          // only needed for ascii\n          // 20230123: matches matches WHATWG, see note 3.3\n          check_label_extension(norm);\n          // cant have fenced\n          // cant have cm\n          // cant have wholes\n          // see derive: \"Fastpath ASCII\"\n          type = 'ASCII';\n        } else {\n          if (emoji) {\n            // there is at least one emoji\n            info.emoji = true;\n            chars = tokens.flatMap(function (x) {\n              return x.is_emoji ? [] : x;\n            }); // all of the nfc tokens concat together\n          }\n\n          norm = tokens.flatMap(function (x) {\n            return !preserve_emoji && x.is_emoji ? filter_fe0f(x) : x;\n          });\n          check_leading_underscore(norm);\n          if (!chars.length) {\n            // theres no text, just emoji\n            type = 'Emoji';\n          } else {\n            // 5. \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\n            if (CM.has(norm[0])) throw error_placement('leading combining mark');\n            for (var i = 1; i < token_count; i++) {\n              // we've already checked the first token\n              var cps = tokens[i];\n              if (!cps.is_emoji && CM.has(cps[0])) {\n                // every text token has emoji neighbors, eg. EtEEEtEt...\n                // bidi_qq() not needed since emoji is LTR and cps is a CM\n                throw error_placement(\"emoji + combining mark: \\\"\".concat(str_from_cps(tokens[i - 1]), \" + \").concat(safe_str_from_cps([cps[0]]), \"\\\"\"));\n              }\n            }\n            check_fenced(norm);\n            var unique = _toConsumableArray(new Set(chars));\n            var _determine_group = determine_group(unique),\n              _determine_group2 = _slicedToArray(_determine_group, 1),\n              g = _determine_group2[0]; // take the first match\n            // see derive: \"Matching Groups have Same CM Style\"\n            // alternative: could form a hybrid type: Latin/Japanese/...\t\n            check_group(g, chars); // need text in order\n            check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\n            type = g.N;\n            // 20230121: consider exposing restricted flag\n            // it's simpler to just check for 'Restricted'\n            // or even better: type.endsWith(']')\n            //if (g.R) info.restricted = true;\n          }\n        }\n      }\n\n      info.type = type;\n    } catch (err) {\n      info.error = err; // use full error object\n    }\n\n    info.output = norm;\n    return info;\n  });\n}\nfunction check_whole(group, unique) {\n  var maker;\n  var shared = []; // TODO: can this be avoided?\n  var _iterator8 = _createForOfIteratorHelper(unique),\n    _step8;\n  try {\n    var _loop2 = function _loop2() {\n      var cp = _step8.value;\n      var whole = WHOLE_MAP.get(cp);\n      if (whole === UNIQUE_PH) return {\n        v: void 0\n      }; // unique, non-confusable\n      if (whole) {\n        var set = whole.M.get(cp); // groups which have a character that look-like this character\n        maker = maker ? maker.filter(function (g) {\n          return set.has(g);\n        }) : _toConsumableArray(set);\n        if (!maker.length) return {\n          v: void 0\n        }; // confusable intersection is empty\n      } else {\n        shared.push(cp);\n      }\n    };\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var _ret = _loop2();\n      if (typeof _ret === \"object\") return _ret.v;\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n  if (maker) {\n    // we have 1+ confusable\n    // check if any of the remaning groups\n    // contain the shared characters too\n    var _iterator9 = _createForOfIteratorHelper(maker),\n      _step9;\n    try {\n      var _loop = function _loop() {\n        var g = _step9.value;\n        if (shared.every(function (cp) {\n          return g.V.has(cp);\n        })) {\n          throw new Error(\"whole-script confusable: \".concat(group.N, \"/\").concat(g.N));\n        }\n      };\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        _loop();\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n  }\n}\n\n// assumption: unique.size > 0\n// returns list of matching groups\nfunction determine_group(unique) {\n  var groups = GROUPS;\n  var _iterator10 = _createForOfIteratorHelper(unique),\n    _step10;\n  try {\n    var _loop3 = function _loop3() {\n      var cp = _step10.value;\n      // note: we need to dodge CM that are whitelisted\n      // but that code isn't currently necessary\n      var gs = groups.filter(function (g) {\n        return g.V.has(cp);\n      });\n      if (!gs.length) {\n        if (groups === GROUPS) {\n          // the character was composed of valid parts\n          // but it's NFC form is invalid\n          throw error_disallowed(cp); // this should be rare\n        } else {\n          // there is no group that contains all these characters\n          // throw using the highest priority group that matched\n          // https://www.unicode.org/reports/tr39/#mixed_script_confusables\n          throw error_group_member(groups[0], cp);\n        }\n      }\n      groups = gs;\n      if (gs.length == 1) return \"break\"; // there is only one group left\n    };\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var _ret2 = _loop3();\n      if (_ret2 === \"break\") break;\n    }\n    // there are at least 1 group(s) with all of these characters\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n  return groups;\n}\n\n// throw on first error\nfunction flatten(split) {\n  return split.map(function (_ref) {\n    var input = _ref.input,\n      error = _ref.error,\n      output = _ref.output;\n    if (error) {\n      // don't print label again if just a single label\n      var msg = error.message;\n      // bidi_qq() only necessary if msg is digits\n      throw new Error(split.length == 1 ? msg : \"Invalid label \".concat(bidi_qq(safe_str_from_cps(input)), \": \").concat(msg));\n    }\n    return str_from_cps(output);\n  }).join(STOP_CH);\n}\nfunction error_disallowed(cp) {\n  // TODO: add cp to error?\n  return new Error(\"disallowed character: \".concat(quoted_cp(cp)));\n}\nfunction error_group_member(g, cp) {\n  var quoted = quoted_cp(cp);\n  var gg = GROUPS.find(function (g) {\n    return g.P.has(cp);\n  });\n  if (gg) {\n    quoted = \"\".concat(gg.N, \" \").concat(quoted);\n  }\n  return new Error(\"illegal mixture: \".concat(g.N, \" + \").concat(quoted));\n}\nfunction error_placement(where) {\n  return new Error(\"illegal placement: \".concat(where));\n}\n\n// assumption: cps.length > 0\n// assumption: cps[0] isn't a CM\n// assumption: the previous character isn't an emoji\nfunction check_group(g, cps) {\n  var V = g.V,\n    M = g.M;\n  var _iterator11 = _createForOfIteratorHelper(cps),\n    _step11;\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var _cp = _step11.value;\n      if (!V.has(_cp)) {\n        // for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\n        // at the moment, it's unnecessary to introduce an extra error type\n        // until there exists a whitelisted multi-character\n        //   eg. if (M < 0 && is_combining_mark(cp)) { ... }\n        // there are 3 cases:\n        //   1. illegal cm for wrong group => mixture error\n        //   2. illegal cm for same group => cm error\n        //       requires set of whitelist cm per group: \n        //        eg. new Set([...g.V].flatMap(nfc).filter(cp => CM.has(cp)))\n        //   3. wrong group => mixture error\n        throw error_group_member(g, _cp);\n      }\n    }\n    //if (M >= 0) { // we have a known fixed cm count\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n  if (M) {\n    // we need to check for NSM\n    var _decomposed = nfd(cps);\n    for (var i = 1, e = _decomposed.length; i < e; i++) {\n      // see: assumption\n      // 20230210: bugfix: using cps instead of decomposed h/t Carbon225\n      /*\r\n      if (CM.has(decomposed[i])) {\r\n      \tlet j = i + 1;\r\n      \twhile (j < e && CM.has(decomposed[j])) j++;\r\n      \tif (j - i > M) {\r\n      \t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n      \t}\r\n      \ti = j;\r\n      }\r\n      */\n      // 20230217: switch to NSM counting\n      // https://www.unicode.org/reports/tr39/#Optional_Detection\n      if (NSM.has(_decomposed[i])) {\n        var j = i + 1;\n        for (var cp; j < e && NSM.has(cp = _decomposed[j]); j++) {\n          // a. Forbid sequences of the same nonspacing mark.\n          for (var k = i; k < j; k++) {\n            // O(n^2) but n < 100\n            if (_decomposed[k] == cp) {\n              throw new Error(\"non-spacing marks: repeated \".concat(quoted_cp(cp)));\n            }\n          }\n        }\n        // parse to end so we have full nsm count\n        // b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\n        if (j - i > NSM_MAX) {\n          // note: this slice starts with a base char or spacing-mark cm\n          throw new Error(\"non-spacing marks: too many \".concat(bidi_qq(safe_str_from_cps(_decomposed.slice(i - 1, j))), \" (\").concat(j - i, \"/\").concat(NSM_MAX, \")\"));\n        }\n        i = j;\n      }\n    }\n  }\n  // *** this code currently isn't needed ***\n  /*\r\n  let cm_whitelist = M instanceof Map;\r\n  for (let i = 0, e = cps.length; i < e; ) {\r\n  \tlet cp = cps[i++];\r\n  \tlet seqs = cm_whitelist && M.get(cp);\r\n  \tif (seqs) { \r\n  \t\t// list of codepoints that can follow\r\n  \t\t// if this exists, this will always be 1+\r\n  \t\tlet j = i;\r\n  \t\twhile (j < e && CM.has(cps[j])) j++;\r\n  \t\tlet cms = cps.slice(i, j);\r\n  \t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n  \t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n  \t\ti = j;\r\n  \t} else if (!V.has(cp)) {\r\n  \t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n  \t\tlet quoted = quoted_cp(cp);\r\n  \t\tfor (let cp of cps) {\r\n  \t\t\tlet u = UNIQUE.get(cp);\r\n  \t\t\tif (u && u !== g) {\r\n  \t\t\t\t// if both scripts are restricted this error is confusing\r\n  \t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n  \t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n  \t\t\t\tbreak;\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n  \t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n  \t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n  \t}\r\n  }\r\n  if (!cm_whitelist) {\r\n  \tlet decomposed = nfd(cps);\r\n  \tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n  \t\tif (CM.has(decomposed[i])) {\r\n  \t\t\tlet j = i + 1;\r\n  \t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n  \t\t\tif (j - i > M) {\r\n  \t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n  \t\t\t}\r\n  \t\t\ti = j;\r\n  \t\t}\r\n  \t}\r\n  }\r\n  */\n}\n\n// given a list of codepoints\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\n// eg. explode_cp(\"abc💩d\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\nfunction process(input, nf) {\n  var ret = [];\n  var chars = [];\n  input = input.slice().reverse(); // flip so we can pop\n  while (input.length) {\n    var emoji = consume_emoji_reversed(input);\n    if (emoji) {\n      if (chars.length) {\n        ret.push(nf(chars));\n        chars = [];\n      }\n      ret.push(emoji);\n    } else {\n      var cp = input.pop();\n      if (VALID.has(cp)) {\n        chars.push(cp);\n      } else {\n        var cps = MAPPED.get(cp);\n        if (cps) {\n          var _chars;\n          (_chars = chars).push.apply(_chars, _toConsumableArray(cps));\n        } else if (!IGNORED.has(cp)) {\n          throw error_disallowed(cp);\n        }\n      }\n    }\n  }\n  if (chars.length) {\n    ret.push(nf(chars));\n  }\n  return ret;\n}\nfunction filter_fe0f(cps) {\n  return cps.filter(function (cp) {\n    return cp != FE0F;\n  });\n}\n\n// given array of codepoints\n// returns the longest valid emoji sequence (or undefined if no match)\n// *MUTATES* the supplied array\n// allows optional FE0F\n// disallows interleaved ignored characters\n// fills (optional) eaten array with matched codepoints\nfunction consume_emoji_reversed(cps, eaten) {\n  var node = EMOJI_ROOT;\n  var emoji;\n  var saved;\n  var stack = [];\n  var pos = cps.length;\n  if (eaten) eaten.length = 0; // clear input buffer (if needed)\n  var _loop4 = function _loop4() {\n    var cp = cps[--pos];\n    node = node.B.find(function (x) {\n      return x.Q.has(cp);\n    });\n    if (!node) return \"break\";\n    if (node.S) {\n      // remember\n      saved = cp;\n    } else if (node.C) {\n      // check exclusion\n      if (cp === saved) return \"break\";\n    }\n    stack.push(cp);\n    if (node.F) {\n      stack.push(FE0F);\n      if (pos > 0 && cps[pos - 1] == FE0F) pos--; // consume optional FE0F\n    }\n\n    if (node.V) {\n      // this is a valid emoji (so far)\n      emoji = conform_emoji_copy(stack, node);\n      if (eaten) eaten.push.apply(eaten, _toConsumableArray(cps.slice(pos).reverse())); // copy input (if needed)\n      cps.length = pos; // truncate\n    }\n  };\n  while (pos) {\n    var _ret3 = _loop4();\n    if (_ret3 === \"break\") break;\n  }\n  /*\r\n  // *** this code currently isn't needed ***\r\n  if (!emoji) {\r\n  \tlet cp = cps[cps.length-1];\r\n  \tif (EMOJI_SOLO.has(cp)) {\r\n  \t\tif (eaten) eaten.push(cp);\r\n  \t\temoji = Emoji.of(cp);\r\n  \t\tcps.pop();\r\n  \t}\r\n  }\r\n  */\n  return emoji;\n}\n\n// create a copy and fix any unicode quirks\nfunction conform_emoji_copy(cps, node) {\n  var copy = Emoji.from(cps); // copy stack\n  if (node.V == 2) copy.splice(1, 1); // delete FE0F at position 1 (see: make.js)\n  return copy;\n}\n\n// return all supported emoji as fully-qualified emoji \n// ordered by length then lexicographic \nfunction ens_emoji() {\n  // *** this code currently isn't needed ***\n  //let ret = [...EMOJI_SOLO].map(x => [x]);\n  var ret = [];\n  build(EMOJI_ROOT, []);\n  return ret.sort(compare_arrays);\n  function build(node, cps, saved) {\n    if (node.S) {\n      saved = cps[cps.length - 1];\n    } else if (node.C) {\n      if (saved === cps[cps.length - 1]) return;\n    }\n    if (node.F) cps.push(FE0F);\n    if (node.V) ret.push(conform_emoji_copy(cps, node));\n    var _iterator12 = _createForOfIteratorHelper(node.B),\n      _step12;\n    try {\n      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n        var br = _step12.value;\n        var _iterator13 = _createForOfIteratorHelper(br.Q),\n          _step13;\n        try {\n          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n            var cp = _step13.value;\n            build(br, [].concat(_toConsumableArray(cps), [cp]), saved);\n          }\n        } catch (err) {\n          _iterator13.e(err);\n        } finally {\n          _iterator13.f();\n        }\n      }\n    } catch (err) {\n      _iterator12.e(err);\n    } finally {\n      _iterator12.f();\n    }\n  }\n}\n\n// ************************************************************\n// tokenizer \n\nvar TY_VALID = 'valid';\nvar TY_MAPPED = 'mapped';\nvar TY_IGNORED = 'ignored';\nvar TY_DISALLOWED = 'disallowed';\nvar TY_EMOJI = 'emoji';\nvar TY_NFC = 'nfc';\nvar TY_STOP = 'stop';\nfunction ens_tokenize(name) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref2$nf = _ref2.nf,\n    nf = _ref2$nf === void 0 ? true : _ref2$nf;\n  var input = explode_cp(name).reverse();\n  var eaten = [];\n  var tokens = [];\n  while (input.length) {\n    var emoji = consume_emoji_reversed(input, eaten);\n    if (emoji) {\n      tokens.push({\n        type: TY_EMOJI,\n        emoji: emoji,\n        input: eaten.slice(),\n        cps: filter_fe0f(emoji)\n      });\n    } else {\n      var cp = input.pop();\n      if (cp == STOP) {\n        tokens.push({\n          type: TY_STOP,\n          cp: cp\n        });\n      } else if (VALID.has(cp)) {\n        tokens.push({\n          type: TY_VALID,\n          cps: [cp]\n        });\n      } else if (IGNORED.has(cp)) {\n        tokens.push({\n          type: TY_IGNORED,\n          cp: cp\n        });\n      } else {\n        var cps = MAPPED.get(cp);\n        if (cps) {\n          tokens.push({\n            type: TY_MAPPED,\n            cp: cp,\n            cps: cps.slice()\n          });\n        } else {\n          tokens.push({\n            type: TY_DISALLOWED,\n            cp: cp\n          });\n        }\n      }\n    }\n  }\n  if (nf) {\n    for (var i = 0, start = -1; i < tokens.length; i++) {\n      var token = tokens[i];\n      if (is_valid_or_mapped(token.type)) {\n        if (requires_check(token.cps)) {\n          // normalization might be needed\n          var end = i + 1;\n          for (var pos = end; pos < tokens.length; pos++) {\n            // find adjacent text\n            var _tokens$pos = tokens[pos],\n              type = _tokens$pos.type,\n              _cps = _tokens$pos.cps;\n            if (is_valid_or_mapped(type)) {\n              if (!requires_check(_cps)) break;\n              end = pos + 1;\n            } else if (type !== TY_IGNORED) {\n              // || type !== TY_DISALLOWED) { \n              break;\n            }\n          }\n          if (start < 0) start = i;\n          var slice = tokens.slice(start, end);\n          var cps0 = slice.flatMap(function (x) {\n            return is_valid_or_mapped(x.type) ? x.cps : [];\n          }); // strip junk tokens\n          var _cps2 = nfc(cps0);\n          if (compare_arrays(_cps2, cps0)) {\n            // bundle into an nfc token\n            tokens.splice(start, end - start, {\n              type: TY_NFC,\n              input: cps0,\n              // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps\n              cps: _cps2,\n              tokens0: collapse_valid_tokens(slice),\n              tokens: ens_tokenize(str_from_cps(_cps2), {\n                nf: false\n              })\n            });\n            i = start;\n          } else {\n            i = end - 1; // skip to end of slice\n          }\n\n          start = -1; // reset\n        } else {\n          start = i; // remember last\n        }\n      } else if (token.type !== TY_IGNORED) {\n        // 20221024: is this correct?\n        start = -1; // reset\n      }\n    }\n  }\n\n  return collapse_valid_tokens(tokens);\n}\nfunction is_valid_or_mapped(type) {\n  return type == TY_VALID || type == TY_MAPPED;\n}\nfunction requires_check(cps) {\n  return cps.some(function (cp) {\n    return NFC_CHECK.has(cp);\n  });\n}\nfunction collapse_valid_tokens(tokens) {\n  for (var i = 0; i < tokens.length; i++) {\n    if (tokens[i].type == TY_VALID) {\n      var j = i + 1;\n      while (j < tokens.length && tokens[j].type == TY_VALID) j++;\n      tokens.splice(i, j - i, {\n        type: TY_VALID,\n        cps: tokens.slice(i, j).flatMap(function (x) {\n          return x.cps;\n        })\n      });\n    }\n  }\n  return tokens;\n}\nexport { ens_beautify, ens_emoji, ens_normalize, ens_normalize_fragment, ens_split, ens_tokenize, is_combining_mark, nfc, nfd, safe_str_from_cps, should_escape };","map":null,"metadata":{},"sourceType":"module"}