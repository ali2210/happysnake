{"ast":null,"code":"import { keccak256 } from \"../crypto/index.js\";\nimport { concat, dataSlice, getBigInt, getBytes, encodeRlp, assertArgument } from \"../utils/index.js\";\nimport { getAddress } from \"./address.js\";\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\n/**\n *  Returns the address that would result from a ``CREATE`` for %%tx%%.\n *\n *  This can be used to compute the address a contract will be\n *  deployed to by an EOA when sending a deployment transaction (i.e.\n *  when the ``to`` address is ``null``).\n *\n *  This can also be used to compute the address a contract will be\n *  deployed to by a contract, by using the contract's address as the\n *  ``to`` and the contract's nonce.\n *\n *  @example\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\";\n *    nonce = 5;\n *\n *    getCreateAddress({ from, nonce });\n *    //_result:\n */\nexport function getCreateAddress(tx) {\n  var from = getAddress(tx.from);\n  var nonce = getBigInt(tx.nonce, \"tx.nonce\");\n  var nonceHex = nonce.toString(16);\n  if (nonceHex === \"0\") {\n    nonceHex = \"0x\";\n  } else if (nonceHex.length % 2) {\n    nonceHex = \"0x0\" + nonceHex;\n  } else {\n    nonceHex = \"0x\" + nonceHex;\n  }\n  return getAddress(dataSlice(keccak256(encodeRlp([from, nonceHex])), 12));\n}\n/**\n *  Returns the address that would result from a ``CREATE2`` operation\n *  with the given %%from%%, %%salt%% and %%initCodeHash%%.\n *\n *  To compute the %%initCodeHash%% from a contract's init code, use\n *  the [[keccak256]] function.\n *\n *  For a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].\n *\n *  @example\n *    // The address of the contract\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\"\n *\n *    // The salt\n *    salt = id(\"HelloWorld\")\n *\n *    // The hash of the initCode\n *    initCode = \"0x6394198df16000526103ff60206004601c335afa6040516060f3\";\n *    initCodeHash = keccak256(initCode)\n *\n *    getCreate2Address(from, salt, initCodeHash)\n *    //_result:\n */\nexport function getCreate2Address(_from, _salt, _initCodeHash) {\n  var from = getAddress(_from);\n  var salt = getBytes(_salt, \"salt\");\n  var initCodeHash = getBytes(_initCodeHash, \"initCodeHash\");\n  assertArgument(salt.length === 32, \"salt must be 32 bytes\", \"salt\", _salt);\n  assertArgument(initCodeHash.length === 32, \"initCodeHash must be 32 bytes\", \"initCodeHash\", _initCodeHash);\n  return getAddress(dataSlice(keccak256(concat([\"0xff\", from, salt, initCodeHash])), 12));\n}","map":null,"metadata":{},"sourceType":"module"}