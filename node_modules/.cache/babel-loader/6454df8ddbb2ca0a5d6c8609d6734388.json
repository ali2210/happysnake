{"ast":null,"code":"/* Browser Crypto Shims */\nimport { hmac } from \"@noble/hashes/hmac\";\nimport { pbkdf2 } from \"@noble/hashes/pbkdf2\";\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport { sha512 } from \"@noble/hashes/sha512\";\nimport { assert, assertArgument } from \"../utils/index.js\";\nfunction getGlobal() {\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  throw new Error('unable to locate global object');\n}\n;\nvar anyGlobal = getGlobal();\nvar crypto = anyGlobal.crypto || anyGlobal.msCrypto;\nexport function createHash(algo) {\n  switch (algo) {\n    case \"sha256\":\n      return sha256.create();\n    case \"sha512\":\n      return sha512.create();\n  }\n  assertArgument(false, \"invalid hashing algorithm name\", \"algorithm\", algo);\n}\nexport function createHmac(_algo, key) {\n  var algo = {\n    sha256: sha256,\n    sha512: sha512\n  }[_algo];\n  assertArgument(algo != null, \"invalid hmac algorithm\", \"algorithm\", _algo);\n  return hmac.create(algo, key);\n}\nexport function pbkdf2Sync(password, salt, iterations, keylen, _algo) {\n  var algo = {\n    sha256: sha256,\n    sha512: sha512\n  }[_algo];\n  assertArgument(algo != null, \"invalid pbkdf2 algorithm\", \"algorithm\", _algo);\n  return pbkdf2(algo, password, salt, {\n    c: iterations,\n    dkLen: keylen\n  });\n}\nexport function randomBytes(length) {\n  assert(crypto != null, \"platform does not support secure random numbers\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"randomBytes\"\n  });\n  assertArgument(Number.isInteger(length) && length > 0 && length <= 1024, \"invalid length\", \"length\", length);\n  var result = new Uint8Array(length);\n  crypto.getRandomValues(result);\n  return result;\n}","map":null,"metadata":{},"sourceType":"module"}