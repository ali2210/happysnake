{"ast":null,"code":"'use strict';\n\nvar assert = require('assert');\nvar getDialect = require('../dialect');\nvar util = require('util');\nvar Node = function (type) {\n  /* jshint unused: false */\n  this.nodes = [];\n};\nNode.prototype.toNode = function () {\n  return this;\n};\nNode.prototype.add = function (node) {\n  assert(node, 'Error while trying to add a non-existant node to a query');\n  var newNode;\n  if (typeof node === 'string') newNode = new TextNode(node);else if (node.toNode) newNode = node.toNode();else newNode = node;\n  this.nodes.push(newNode);\n  return this;\n};\nNode.prototype.unshift = function (node) {\n  assert(node, 'Error while trying to add a non-existant node to a query');\n  this.nodes.unshift(typeof node === 'string' ? new TextNode(node) : node.toNode());\n  return this;\n};\n\n// Before the change that introduced parallel dialects, every node could be turned\n// into a query. The parallel dialects change made it impossible to change some nodes\n// into a query because not all nodes are constructed with the sql instance.\nvar determineDialect = function (query, dialect) {\n  var sql = query.sql || query.table && query.table.sql;\n  var Dialect;\n  if (dialect) {\n    // dialect is specified\n    Dialect = getDialect(dialect);\n  } else if (sql && sql.dialect) {\n    // dialect is not specified, use the dialect from the sql instance\n    Dialect = sql.dialect;\n  } else {\n    // dialect is not specified, use the default dialect\n    Dialect = require('../').dialect;\n  }\n  return Dialect;\n};\nvar initializeDialect = function (Dialect, query) {\n  var config = query.sql ? query.sql.config : {};\n  return new Dialect(config);\n};\nNode.prototype.toQuery = function (dialect) {\n  var Dialect = determineDialect(this, dialect);\n  return initializeDialect(Dialect, this).getQuery(this);\n};\nNode.prototype.toNamedQuery = function (name, dialect) {\n  if (!name || typeof name !== 'string' || name === '') {\n    throw new Error('A query name has to be a non-empty String.');\n  }\n  var query = this.toQuery(dialect);\n  query.name = name;\n  return query;\n};\nNode.prototype.toString = function (dialect) {\n  var Dialect = determineDialect(this, dialect);\n  return initializeDialect(Dialect, this).getString(this);\n};\nNode.prototype.addAll = function (nodes) {\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    this.add(nodes[i]);\n  }\n  return this;\n};\nNode.define = function (def) {\n  var c = function () {\n    Node.call(this);\n  };\n  // allow custom sub-class constructor\n  if (def.constructor && def.constructor !== {}.constructor) {\n    c = def.constructor;\n  }\n  util.inherits(c, Node);\n  for (var key in def) {\n    if (def.hasOwnProperty(key)) {\n      c.prototype[key] = def[key];\n    }\n  }\n  return c;\n};\nmodule.exports = Node;\nvar TextNode = require('./text');","map":{"version":3,"names":["assert","require","getDialect","util","Node","type","nodes","prototype","toNode","add","node","newNode","TextNode","push","unshift","determineDialect","query","dialect","sql","table","Dialect","initializeDialect","config","toQuery","getQuery","toNamedQuery","name","Error","toString","getString","addAll","i","len","length","define","def","c","call","constructor","inherits","key","hasOwnProperty","module","exports"],"sources":["/home/ali/Documents/run_prj/happysnake/node_modules/sql/lib/node/index.js"],"sourcesContent":["'use strict';\n\nvar assert     = require('assert');\nvar getDialect = require('../dialect');\nvar util       = require('util');\n\nvar Node = function(type) {\n  /* jshint unused: false */\n  this.nodes = [];\n};\n\nNode.prototype.toNode = function() {\n  return this;\n};\n\nNode.prototype.add = function(node) {\n  assert(node, 'Error while trying to add a non-existant node to a query');\n\tvar newNode;\n  if (typeof node === 'string') newNode = new TextNode(node);\n  else if (node.toNode) newNode = node.toNode();\n  else newNode = node;\n  this.nodes.push(newNode);\n  return this;\n};\n\nNode.prototype.unshift = function(node) {\n  assert(node, 'Error while trying to add a non-existant node to a query');\n  this.nodes.unshift(typeof node === 'string' ? new TextNode(node) : node.toNode());\n  return this;\n};\n\n// Before the change that introduced parallel dialects, every node could be turned\n// into a query. The parallel dialects change made it impossible to change some nodes\n// into a query because not all nodes are constructed with the sql instance.\nvar determineDialect = function(query, dialect) {\n  var sql = query.sql || (query.table && query.table.sql);\n  var Dialect;\n\n  if (dialect) {\n    // dialect is specified\n    Dialect = getDialect(dialect);\n  } else if (sql && sql.dialect) {\n    // dialect is not specified, use the dialect from the sql instance\n    Dialect = sql.dialect;\n  } else {\n    // dialect is not specified, use the default dialect\n    Dialect = require('../').dialect;\n  }\n  return Dialect;\n};\n\nvar initializeDialect = function(Dialect, query) {\n    var config = query.sql ? query.sql.config : {};\n    return new Dialect(config);\n};\n\nNode.prototype.toQuery = function(dialect) {\n  var Dialect = determineDialect(this, dialect);\n  return initializeDialect(Dialect, this).getQuery(this);\n};\n\nNode.prototype.toNamedQuery = function(name, dialect) {\n  if (!name || typeof name !== 'string' ||  name === '') {\n    throw new Error('A query name has to be a non-empty String.');\n  }\n  var query = this.toQuery(dialect);\n  query.name = name;\n  return query;\n};\n\nNode.prototype.toString = function(dialect) {\n  var Dialect = determineDialect(this, dialect);\n  return initializeDialect(Dialect, this).getString(this);\n};\n\nNode.prototype.addAll = function(nodes) {\n  for(var i = 0, len = nodes.length; i < len; i++) {\n    this.add(nodes[i]);\n  }\n  return this;\n};\n\nNode.define = function(def) {\n  var c = function() {\n    Node.call(this);\n  };\n  // allow custom sub-class constructor\n  if(def.constructor && def.constructor !== {}.constructor) {\n    c = def.constructor;\n  }\n  util.inherits(c, Node);\n  for (var key in def) {\n    if (def.hasOwnProperty(key)) {\n      c.prototype[key] = def[key];\n    }\n  }\n  return c;\n};\n\nmodule.exports = Node;\nvar TextNode = require('./text');\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,MAAM,GAAOC,OAAO,CAAC,QAAQ,CAAC;AAClC,IAAIC,UAAU,GAAGD,OAAO,CAAC,YAAY,CAAC;AACtC,IAAIE,IAAI,GAASF,OAAO,CAAC,MAAM,CAAC;AAEhC,IAAIG,IAAI,GAAG,SAAAA,CAASC,IAAI,EAAE;EACxB;EACA,IAAI,CAACC,KAAK,GAAG,EAAE;AACjB,CAAC;AAEDF,IAAI,CAACG,SAAS,CAACC,MAAM,GAAG,YAAW;EACjC,OAAO,IAAI;AACb,CAAC;AAEDJ,IAAI,CAACG,SAAS,CAACE,GAAG,GAAG,UAASC,IAAI,EAAE;EAClCV,MAAM,CAACU,IAAI,EAAE,0DAA0D,CAAC;EACzE,IAAIC,OAAO;EACV,IAAI,OAAOD,IAAI,KAAK,QAAQ,EAAEC,OAAO,GAAG,IAAIC,QAAQ,CAACF,IAAI,CAAC,CAAC,KACtD,IAAIA,IAAI,CAACF,MAAM,EAAEG,OAAO,GAAGD,IAAI,CAACF,MAAM,CAAC,CAAC,CAAC,KACzCG,OAAO,GAAGD,IAAI;EACnB,IAAI,CAACJ,KAAK,CAACO,IAAI,CAACF,OAAO,CAAC;EACxB,OAAO,IAAI;AACb,CAAC;AAEDP,IAAI,CAACG,SAAS,CAACO,OAAO,GAAG,UAASJ,IAAI,EAAE;EACtCV,MAAM,CAACU,IAAI,EAAE,0DAA0D,CAAC;EACxE,IAAI,CAACJ,KAAK,CAACQ,OAAO,CAAC,OAAOJ,IAAI,KAAK,QAAQ,GAAG,IAAIE,QAAQ,CAACF,IAAI,CAAC,GAAGA,IAAI,CAACF,MAAM,CAAC,CAAC,CAAC;EACjF,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA,IAAIO,gBAAgB,GAAG,SAAAA,CAASC,KAAK,EAAEC,OAAO,EAAE;EAC9C,IAAIC,GAAG,GAAGF,KAAK,CAACE,GAAG,IAAKF,KAAK,CAACG,KAAK,IAAIH,KAAK,CAACG,KAAK,CAACD,GAAI;EACvD,IAAIE,OAAO;EAEX,IAAIH,OAAO,EAAE;IACX;IACAG,OAAO,GAAGlB,UAAU,CAACe,OAAO,CAAC;EAC/B,CAAC,MAAM,IAAIC,GAAG,IAAIA,GAAG,CAACD,OAAO,EAAE;IAC7B;IACAG,OAAO,GAAGF,GAAG,CAACD,OAAO;EACvB,CAAC,MAAM;IACL;IACAG,OAAO,GAAGnB,OAAO,CAAC,KAAK,CAAC,CAACgB,OAAO;EAClC;EACA,OAAOG,OAAO;AAChB,CAAC;AAED,IAAIC,iBAAiB,GAAG,SAAAA,CAASD,OAAO,EAAEJ,KAAK,EAAE;EAC7C,IAAIM,MAAM,GAAGN,KAAK,CAACE,GAAG,GAAGF,KAAK,CAACE,GAAG,CAACI,MAAM,GAAG,CAAC,CAAC;EAC9C,OAAO,IAAIF,OAAO,CAACE,MAAM,CAAC;AAC9B,CAAC;AAEDlB,IAAI,CAACG,SAAS,CAACgB,OAAO,GAAG,UAASN,OAAO,EAAE;EACzC,IAAIG,OAAO,GAAGL,gBAAgB,CAAC,IAAI,EAAEE,OAAO,CAAC;EAC7C,OAAOI,iBAAiB,CAACD,OAAO,EAAE,IAAI,CAAC,CAACI,QAAQ,CAAC,IAAI,CAAC;AACxD,CAAC;AAEDpB,IAAI,CAACG,SAAS,CAACkB,YAAY,GAAG,UAASC,IAAI,EAAET,OAAO,EAAE;EACpD,IAAI,CAACS,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,IAAKA,IAAI,KAAK,EAAE,EAAE;IACrD,MAAM,IAAIC,KAAK,CAAC,4CAA4C,CAAC;EAC/D;EACA,IAAIX,KAAK,GAAG,IAAI,CAACO,OAAO,CAACN,OAAO,CAAC;EACjCD,KAAK,CAACU,IAAI,GAAGA,IAAI;EACjB,OAAOV,KAAK;AACd,CAAC;AAEDZ,IAAI,CAACG,SAAS,CAACqB,QAAQ,GAAG,UAASX,OAAO,EAAE;EAC1C,IAAIG,OAAO,GAAGL,gBAAgB,CAAC,IAAI,EAAEE,OAAO,CAAC;EAC7C,OAAOI,iBAAiB,CAACD,OAAO,EAAE,IAAI,CAAC,CAACS,SAAS,CAAC,IAAI,CAAC;AACzD,CAAC;AAEDzB,IAAI,CAACG,SAAS,CAACuB,MAAM,GAAG,UAASxB,KAAK,EAAE;EACtC,KAAI,IAAIyB,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG1B,KAAK,CAAC2B,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;IAC/C,IAAI,CAACtB,GAAG,CAACH,KAAK,CAACyB,CAAC,CAAC,CAAC;EACpB;EACA,OAAO,IAAI;AACb,CAAC;AAED3B,IAAI,CAAC8B,MAAM,GAAG,UAASC,GAAG,EAAE;EAC1B,IAAIC,CAAC,GAAG,SAAAA,CAAA,EAAW;IACjBhC,IAAI,CAACiC,IAAI,CAAC,IAAI,CAAC;EACjB,CAAC;EACD;EACA,IAAGF,GAAG,CAACG,WAAW,IAAIH,GAAG,CAACG,WAAW,KAAK,CAAC,CAAC,CAACA,WAAW,EAAE;IACxDF,CAAC,GAAGD,GAAG,CAACG,WAAW;EACrB;EACAnC,IAAI,CAACoC,QAAQ,CAACH,CAAC,EAAEhC,IAAI,CAAC;EACtB,KAAK,IAAIoC,GAAG,IAAIL,GAAG,EAAE;IACnB,IAAIA,GAAG,CAACM,cAAc,CAACD,GAAG,CAAC,EAAE;MAC3BJ,CAAC,CAAC7B,SAAS,CAACiC,GAAG,CAAC,GAAGL,GAAG,CAACK,GAAG,CAAC;IAC7B;EACF;EACA,OAAOJ,CAAC;AACV,CAAC;AAEDM,MAAM,CAACC,OAAO,GAAGvC,IAAI;AACrB,IAAIQ,QAAQ,GAAGX,OAAO,CAAC,QAAQ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}