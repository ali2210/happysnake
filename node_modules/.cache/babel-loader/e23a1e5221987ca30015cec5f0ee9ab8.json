{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */\nimport { hexlify, isBytesLike } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\nvar BN_0 = BigInt(0);\nvar BN_1 = BigInt(1);\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n// IEEE 754 support 53-bits of mantissa\nvar maxValue = 0x1fffffffffffff;\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */\nexport function fromTwos(_value, _width) {\n  var value = getUint(_value, \"value\");\n  var width = BigInt(getNumber(_width, \"width\"));\n  assert(value >> width === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n    operation: \"fromTwos\",\n    fault: \"overflow\",\n    value: _value\n  });\n  // Top bit set; treat as a negative value\n  if (value >> width - BN_1) {\n    var _mask = (BN_1 << width) - BN_1;\n    return -((~value & _mask) + BN_1);\n  }\n  return value;\n}\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */\nexport function toTwos(_value, _width) {\n  var value = getBigInt(_value, \"value\");\n  var width = BigInt(getNumber(_width, \"width\"));\n  var limit = BN_1 << width - BN_1;\n  if (value < BN_0) {\n    value = -value;\n    assert(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n      operation: \"toTwos\",\n      fault: \"overflow\",\n      value: _value\n    });\n    var _mask2 = (BN_1 << width) - BN_1;\n    return (~value & _mask2) + BN_1;\n  } else {\n    assert(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n      operation: \"toTwos\",\n      fault: \"overflow\",\n      value: _value\n    });\n  }\n  return value;\n}\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */\nexport function mask(_value, _bits) {\n  var value = getUint(_value, \"value\");\n  var bits = BigInt(getNumber(_bits, \"bits\"));\n  return value & (BN_1 << bits) - BN_1;\n}\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */\nexport function getBigInt(value, name) {\n  switch (typeof value) {\n    case \"bigint\":\n      return value;\n    case \"number\":\n      assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n      assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n      return BigInt(value);\n    case \"string\":\n      try {\n        if (value === \"\") {\n          throw new Error(\"empty string\");\n        }\n        if (value[0] === \"-\" && value[1] !== \"-\") {\n          return -BigInt(value.substring(1));\n        }\n        return BigInt(value);\n      } catch (e) {\n        assertArgument(false, \"invalid BigNumberish string: \".concat(e.message), name || \"value\", value);\n      }\n  }\n  assertArgument(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */\nexport function getUint(value, name) {\n  var result = getBigInt(value, name);\n  assert(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n    fault: \"overflow\",\n    operation: \"getUint\",\n    value: value\n  });\n  return result;\n}\nvar Nibbles = \"0123456789abcdef\";\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */\nexport function toBigInt(value) {\n  if (value instanceof Uint8Array) {\n    var result = \"0x0\";\n    var _iterator = _createForOfIteratorHelper(value),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var v = _step.value;\n        result += Nibbles[v >> 4];\n        result += Nibbles[v & 0x0f];\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return BigInt(result);\n  }\n  return getBigInt(value);\n}\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */\nexport function getNumber(value, name) {\n  switch (typeof value) {\n    case \"bigint\":\n      assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n      return Number(value);\n    case \"number\":\n      assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n      assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n      return value;\n    case \"string\":\n      try {\n        if (value === \"\") {\n          throw new Error(\"empty string\");\n        }\n        return getNumber(BigInt(value), name);\n      } catch (e) {\n        assertArgument(false, \"invalid numeric string: \".concat(e.message), name || \"value\", value);\n      }\n  }\n  assertArgument(false, \"invalid numeric value\", name || \"value\", value);\n}\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */\nexport function toNumber(value) {\n  return getNumber(toBigInt(value));\n}\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */\nexport function toBeHex(_value, _width) {\n  var value = getUint(_value, \"value\");\n  var result = value.toString(16);\n  if (_width == null) {\n    // Ensure the value is of even length\n    if (result.length % 2) {\n      result = \"0\" + result;\n    }\n  } else {\n    var width = getNumber(_width, \"width\");\n    assert(width * 2 >= result.length, \"value exceeds width (\".concat(width, \" bits)\"), \"NUMERIC_FAULT\", {\n      operation: \"toBeHex\",\n      fault: \"overflow\",\n      value: _value\n    });\n    // Pad the value to the required width\n    while (result.length < width * 2) {\n      result = \"0\" + result;\n    }\n  }\n  return \"0x\" + result;\n}\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */\nexport function toBeArray(_value) {\n  var value = getUint(_value, \"value\");\n  if (value === BN_0) {\n    return new Uint8Array([]);\n  }\n  var hex = value.toString(16);\n  if (hex.length % 2) {\n    hex = \"0\" + hex;\n  }\n  var result = new Uint8Array(hex.length / 2);\n  for (var i = 0; i < result.length; i++) {\n    var offset = i * 2;\n    result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n  }\n  return result;\n}\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */\nexport function toQuantity(value) {\n  var result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);\n  while (result.startsWith(\"0\")) {\n    result = result.substring(1);\n  }\n  if (result === \"\") {\n    result = \"0\";\n  }\n  return \"0x\" + result;\n}","map":null,"metadata":{},"sourceType":"module"}