{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/ali/Documents/run_prj/happysnake/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/ali/Documents/run_prj/happysnake/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/home/ali/Documents/run_prj/happysnake/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/home/ali/Documents/run_prj/happysnake/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/home/ali/Documents/run_prj/happysnake/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ripemd160 = exports.RIPEMD160 = void 0;\nvar _sha2_js_1 = require(\"./_sha2.js\");\nvar utils_js_1 = require(\"./utils.js\");\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nvar Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nvar Id = Uint8Array.from({\n  length: 16\n}, function (_, i) {\n  return i;\n});\nvar Pi = Id.map(function (i) {\n  return (9 * i + 5) % 16;\n});\nvar idxL = [Id];\nvar idxR = [Pi];\nfor (var i = 0; i < 4; i++) for (var _i = 0, _arr = [idxL, idxR]; _i < _arr.length; _i++) {\n  var j = _arr[_i];\n  j.push(j[i].map(function (k) {\n    return Rho[k];\n  }));\n}\nvar shifts = [[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8], [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7], [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9], [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6], [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]].map(function (i) {\n  return new Uint8Array(i);\n});\nvar shiftsL = idxL.map(function (idx, i) {\n  return idx.map(function (j) {\n    return shifts[i][j];\n  });\n});\nvar shiftsR = idxR.map(function (idx, i) {\n  return idx.map(function (j) {\n    return shifts[i][j];\n  });\n});\nvar Kl = new Uint32Array([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);\nvar Kr = new Uint32Array([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);\n// The rotate left (circular left shift) operation for uint32\nvar rotl = function rotl(word, shift) {\n  return word << shift | word >>> 32 - shift;\n};\n// It's called f() in spec.\nfunction f(group, x, y, z) {\n  if (group === 0) return x ^ y ^ z;else if (group === 1) return x & y | ~x & z;else if (group === 2) return (x | ~y) ^ z;else if (group === 3) return x & z | y & ~z;else return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nvar BUF = new Uint32Array(16);\nvar RIPEMD160 = /*#__PURE__*/function (_sha2_js_1$SHA) {\n  _inherits(RIPEMD160, _sha2_js_1$SHA);\n  function RIPEMD160() {\n    var _this;\n    _classCallCheck(this, RIPEMD160);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RIPEMD160).call(this, 64, 20, 8, true));\n    _this.h0 = 0x67452301 | 0;\n    _this.h1 = 0xefcdab89 | 0;\n    _this.h2 = 0x98badcfe | 0;\n    _this.h3 = 0x10325476 | 0;\n    _this.h4 = 0xc3d2e1f0 | 0;\n    return _this;\n  }\n  _createClass(RIPEMD160, [{\n    key: \"get\",\n    value: function get() {\n      var h0 = this.h0,\n        h1 = this.h1,\n        h2 = this.h2,\n        h3 = this.h3,\n        h4 = this.h4;\n      return [h0, h1, h2, h3, h4];\n    }\n  }, {\n    key: \"set\",\n    value: function set(h0, h1, h2, h3, h4) {\n      this.h0 = h0 | 0;\n      this.h1 = h1 | 0;\n      this.h2 = h2 | 0;\n      this.h3 = h3 | 0;\n      this.h4 = h4 | 0;\n    }\n  }, {\n    key: \"process\",\n    value: function process(view, offset) {\n      for (var _i2 = 0; _i2 < 16; _i2++, offset += 4) BUF[_i2] = view.getUint32(offset, true);\n      // prettier-ignore\n      var al = this.h0 | 0,\n        ar = al,\n        bl = this.h1 | 0,\n        br = bl,\n        cl = this.h2 | 0,\n        cr = cl,\n        dl = this.h3 | 0,\n        dr = dl,\n        el = this.h4 | 0,\n        er = el;\n      // Instead of iterating 0 to 80, we split it into 5 groups\n      // And use the groups in constants, functions, etc. Much simpler\n      for (var group = 0; group < 5; group++) {\n        var rGroup = 4 - group;\n        var hbl = Kl[group],\n          hbr = Kr[group]; // prettier-ignore\n        var rl = idxL[group],\n          rr = idxR[group]; // prettier-ignore\n        var sl = shiftsL[group],\n          sr = shiftsR[group]; // prettier-ignore\n        for (var _i3 = 0; _i3 < 16; _i3++) {\n          var tl = rotl(al + f(group, bl, cl, dl) + BUF[rl[_i3]] + hbl, sl[_i3]) + el | 0;\n          al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n        }\n        // 2 loops are 10% faster\n        for (var _i4 = 0; _i4 < 16; _i4++) {\n          var tr = rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[_i4]] + hbr, sr[_i4]) + er | 0;\n          ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n        }\n      }\n      // Add the compressed chunk to the current hash value\n      this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);\n    }\n  }, {\n    key: \"roundClean\",\n    value: function roundClean() {\n      BUF.fill(0);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.destroyed = true;\n      this.buffer.fill(0);\n      this.set(0, 0, 0, 0, 0);\n    }\n  }]);\n  return RIPEMD160;\n}(_sha2_js_1.SHA2);\nexports.RIPEMD160 = RIPEMD160;\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nexports.ripemd160 = (0, utils_js_1.wrapConstructor)(function () {\n  return new RIPEMD160();\n});","map":null,"metadata":{},"sourceType":"script"}