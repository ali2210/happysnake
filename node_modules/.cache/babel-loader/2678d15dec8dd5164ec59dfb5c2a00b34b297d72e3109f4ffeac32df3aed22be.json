{"ast":null,"code":"'use strict';\n\nvar OrderByValueNode = require('./orderByValue');\nvar ParameterNode = require('./parameter');\nvar TextNode = require('./text');\n\n// Process values, wrapping them in ParameterNode if necessary.\nvar processParams = function (val) {\n  return Array.isArray(val) ? val.map(ParameterNode.getNodeOrParameterNode) : ParameterNode.getNodeOrParameterNode(val);\n};\n\n// Value expressions can be composed to form new value expressions.\n// ValueExpressionMixin is evaluated at runtime, hence the\n// \"thunk\" around it.\nvar ValueExpressionMixin = function () {\n  var BinaryNode = require('./binary');\n  var InNode = require('./in');\n  var NotInNode = require('./notIn');\n  var CastNode = require('./cast');\n  var PostfixUnaryNode = require('./postfixUnary');\n  var TernaryNode = require('./ternary');\n  var CaseNode = require('./case');\n  var AtNode = require('./at');\n  var SliceNode = require('./slice');\n  var postfixUnaryMethod = function (operator) {\n    /*jshint unused: false */\n    return function (val) {\n      return new PostfixUnaryNode({\n        left: this.toNode(),\n        operator: operator\n      });\n    };\n  };\n  var binaryMethod = function (operator) {\n    return function (val) {\n      return new BinaryNode({\n        left: this.toNode(),\n        operator: operator,\n        right: processParams(val)\n      });\n    };\n  };\n  var inMethod = function (val) {\n    return new InNode({\n      left: this.toNode(),\n      right: processParams(val)\n    });\n  };\n  var notInMethod = function (val) {\n    return new NotInNode({\n      left: this.toNode(),\n      right: processParams(val)\n    });\n  };\n  var ternaryMethod = function (operator, separator) {\n    return function (middle, right) {\n      return new TernaryNode({\n        left: this.toNode(),\n        operator: operator,\n        middle: processParams(middle),\n        separator: separator,\n        right: processParams(right)\n      });\n    };\n  };\n  var atMethod = function (index) {\n    return new AtNode(this.toNode(), processParams(index));\n  };\n  var sliceMethod = function (start, end) {\n    return new SliceNode(this.toNode(), processParams(start), processParams(end));\n  };\n  var castMethod = function (dataType) {\n    return new CastNode(this.toNode(), dataType);\n  };\n  var orderMethod = function (direction) {\n    return function () {\n      return new OrderByValueNode({\n        value: this.toNode(),\n        direction: direction ? new TextNode(direction) : undefined\n      });\n    };\n  };\n  var caseMethod = function (whenList, thenList, elseBranch) {\n    if (undefined !== elseBranch) {\n      elseBranch = processParams(elseBranch);\n    }\n    return new CaseNode({\n      whenList: processParams(whenList),\n      thenList: processParams(thenList),\n      else: elseBranch\n    });\n  };\n  return {\n    isNull: postfixUnaryMethod('IS NULL'),\n    isNotNull: postfixUnaryMethod('IS NOT NULL'),\n    or: binaryMethod('OR'),\n    and: binaryMethod('AND'),\n    equals: binaryMethod('='),\n    equal: binaryMethod('='),\n    notEquals: binaryMethod('<>'),\n    notEqual: binaryMethod('<>'),\n    gt: binaryMethod('>'),\n    gte: binaryMethod('>='),\n    lt: binaryMethod('<'),\n    lte: binaryMethod('<='),\n    plus: binaryMethod('+'),\n    minus: binaryMethod('-'),\n    multiply: binaryMethod('*'),\n    divide: binaryMethod('/'),\n    modulo: binaryMethod('%'),\n    leftShift: binaryMethod('<<'),\n    rightShift: binaryMethod('>>'),\n    bitwiseAnd: binaryMethod('&'),\n    bitwiseNot: binaryMethod('~'),\n    bitwiseOr: binaryMethod('|'),\n    bitwiseXor: binaryMethod('#'),\n    regex: binaryMethod('~'),\n    iregex: binaryMethod('~*'),\n    regexp: binaryMethod('REGEXP'),\n    notRegex: binaryMethod('!~'),\n    notIregex: binaryMethod('!~*'),\n    concat: binaryMethod('||'),\n    key: binaryMethod('->'),\n    keyText: binaryMethod('->>'),\n    path: binaryMethod('#>'),\n    pathText: binaryMethod('#>>'),\n    like: binaryMethod('LIKE'),\n    rlike: binaryMethod('RLIKE'),\n    notLike: binaryMethod('NOT LIKE'),\n    ilike: binaryMethod('ILIKE'),\n    notIlike: binaryMethod('NOT ILIKE'),\n    match: binaryMethod('@@'),\n    in: inMethod,\n    notIn: notInMethod,\n    between: ternaryMethod('BETWEEN', 'AND'),\n    notBetween: ternaryMethod('NOT BETWEEN', 'AND'),\n    at: atMethod,\n    contains: binaryMethod('@>'),\n    containedBy: binaryMethod('<@'),\n    containsKey: binaryMethod('?'),\n    overlap: binaryMethod('&&'),\n    slice: sliceMethod,\n    cast: castMethod,\n    descending: orderMethod('DESC'),\n    case: caseMethod\n  };\n};\nmodule.exports = ValueExpressionMixin;","map":{"version":3,"names":["OrderByValueNode","require","ParameterNode","TextNode","processParams","val","Array","isArray","map","getNodeOrParameterNode","ValueExpressionMixin","BinaryNode","InNode","NotInNode","CastNode","PostfixUnaryNode","TernaryNode","CaseNode","AtNode","SliceNode","postfixUnaryMethod","operator","left","toNode","binaryMethod","right","inMethod","notInMethod","ternaryMethod","separator","middle","atMethod","index","sliceMethod","start","end","castMethod","dataType","orderMethod","direction","value","undefined","caseMethod","whenList","thenList","elseBranch","else","isNull","isNotNull","or","and","equals","equal","notEquals","notEqual","gt","gte","lt","lte","plus","minus","multiply","divide","modulo","leftShift","rightShift","bitwiseAnd","bitwiseNot","bitwiseOr","bitwiseXor","regex","iregex","regexp","notRegex","notIregex","concat","key","keyText","path","pathText","like","rlike","notLike","ilike","notIlike","match","in","notIn","between","notBetween","at","contains","containedBy","containsKey","overlap","slice","cast","descending","case","module","exports"],"sources":["/home/ali/Documents/run_prj/happysnake/node_modules/sql/lib/node/valueExpression.js"],"sourcesContent":["'use strict';\n\nvar OrderByValueNode = require('./orderByValue');\nvar ParameterNode    = require('./parameter');\nvar TextNode         = require('./text');\n\n// Process values, wrapping them in ParameterNode if necessary.\nvar processParams = function(val) {\n  return Array.isArray(val) ? val.map(ParameterNode.getNodeOrParameterNode) : ParameterNode.getNodeOrParameterNode(val);\n};\n\n// Value expressions can be composed to form new value expressions.\n// ValueExpressionMixin is evaluated at runtime, hence the\n// \"thunk\" around it.\nvar ValueExpressionMixin = function() {\n  var BinaryNode       = require('./binary');\n  var InNode           = require('./in');\n  var NotInNode        = require('./notIn');\n  var CastNode         = require('./cast');\n  var PostfixUnaryNode = require('./postfixUnary');\n  var TernaryNode      = require('./ternary');\n  var CaseNode         = require('./case');\n  var AtNode           = require('./at');\n  var SliceNode        = require('./slice');\n\n  var postfixUnaryMethod = function(operator) {\n    /*jshint unused: false */\n    return function(val) {\n      return new PostfixUnaryNode({\n        left     : this.toNode(),\n        operator : operator\n      });\n    };\n  };\n\n  var binaryMethod = function(operator) {\n    return function(val) {\n      return new BinaryNode({\n        left     : this.toNode(),\n        operator : operator,\n        right    : processParams(val)\n      });\n    };\n  };\n\n  var inMethod = function(val) {\n    return new InNode({\n      left  : this.toNode(),\n      right : processParams(val)\n    });\n  };\n\n  var notInMethod = function(val) {\n    return new NotInNode({\n      left  : this.toNode(),\n      right : processParams(val)\n    });\n  };\n\n  var ternaryMethod = function(operator, separator) {\n    return function(middle, right) {\n      return new TernaryNode({\n        left      : this.toNode(),\n        operator  : operator,\n        middle    : processParams(middle),\n        separator : separator,\n        right     : processParams(right)\n      });\n    };\n  };\n\n  var atMethod = function(index) {\n    return new AtNode(this.toNode(), processParams(index));\n  };\n\n  var sliceMethod = function(start, end) {\n    return new SliceNode(this.toNode(), processParams(start), processParams(end));\n  };\n\n  var castMethod = function(dataType) {\n    return new CastNode(this.toNode(), dataType);\n  };\n\n  var orderMethod = function(direction) {\n    return function() {\n      return new OrderByValueNode({\n        value     : this.toNode(),\n        direction : direction ? new TextNode(direction) : undefined\n      });\n    };\n  };\n\n  var caseMethod = function(whenList, thenList, elseBranch) {\n    if (undefined !== elseBranch) {\n      elseBranch = processParams(elseBranch);\n    }\n    return new CaseNode({\n      whenList : processParams(whenList),\n      thenList : processParams(thenList),\n      else     : elseBranch\n    });\n  };\n\n  return {\n    isNull     : postfixUnaryMethod('IS NULL'),\n    isNotNull  : postfixUnaryMethod('IS NOT NULL'),\n    or         : binaryMethod('OR'),\n    and        : binaryMethod('AND'),\n    equals     : binaryMethod('='),\n    equal      : binaryMethod('='),\n    notEquals  : binaryMethod('<>'),\n    notEqual   : binaryMethod('<>'),\n    gt         : binaryMethod('>'),\n    gte        : binaryMethod('>='),\n    lt         : binaryMethod('<'),\n    lte        : binaryMethod('<='),\n    plus       : binaryMethod('+'),\n    minus      : binaryMethod('-'),\n    multiply   : binaryMethod('*'),\n    divide     : binaryMethod('/'),\n    modulo     : binaryMethod('%'),\n    leftShift  : binaryMethod('<<'),\n    rightShift : binaryMethod('>>'),\n    bitwiseAnd : binaryMethod('&'),\n    bitwiseNot : binaryMethod('~'),\n    bitwiseOr  : binaryMethod('|'),\n    bitwiseXor : binaryMethod('#'),\n    regex      : binaryMethod('~'),\n    iregex     : binaryMethod('~*'),\n    regexp     : binaryMethod('REGEXP'),\n    notRegex   : binaryMethod('!~'),\n    notIregex   : binaryMethod('!~*'),\n    concat     : binaryMethod('||'),\n    key        : binaryMethod('->'),\n    keyText    : binaryMethod('->>'),\n    path       : binaryMethod('#>'),\n    pathText   : binaryMethod('#>>'),\n    like       : binaryMethod('LIKE'),\n    rlike      : binaryMethod('RLIKE'),\n    notLike    : binaryMethod('NOT LIKE'),\n    ilike       : binaryMethod('ILIKE'),\n    notIlike    : binaryMethod('NOT ILIKE'),\n    match      : binaryMethod('@@'),\n    in         : inMethod,\n    notIn      : notInMethod,\n    between    : ternaryMethod('BETWEEN', 'AND'),\n    notBetween : ternaryMethod('NOT BETWEEN', 'AND'),\n    at         : atMethod,\n    contains   : binaryMethod('@>'),\n    containedBy : binaryMethod('<@'),\n    containsKey : binaryMethod('?'),\n    overlap    : binaryMethod('&&'),\n    slice      : sliceMethod,\n    cast       : castMethod,\n    descending : orderMethod('DESC'),\n    case       : caseMethod\n  };\n};\n\nmodule.exports = ValueExpressionMixin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}