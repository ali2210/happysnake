{"ast":null,"code":"'use strict';\n\nvar DefaultNode = require('./default');\nvar Node = require('./');\nvar ParameterNode = require('./parameter');\nvar Insert = Node.define({\n  type: 'INSERT',\n  constructor: function () {\n    Node.call(this);\n    this.names = [];\n    this.columns = [];\n    this.valueSets = [];\n  }\n});\nmodule.exports = Insert;\nInsert.prototype.add = function (nodes) {\n  var hasColumns = false;\n  var hasValues = false;\n  var self = this;\n  var values = {};\n  nodes.forEach(function (node) {\n    var column = node.toNode();\n    var name = column.name;\n    var idx = self.names.indexOf(name);\n    if (idx < 0) {\n      self.names.push(name);\n      self.columns.push(column);\n    }\n    hasColumns = true;\n    hasValues = hasValues || column.value !== undefined;\n    values[name] = column;\n  });\n\n  // When none of the columns have a value, it's ambiguous whether the user\n  // intends to insert a row of default values or append a SELECT statement\n  // later.  Resolve the ambiguity by assuming that if no columns are specified\n  // it is a row of default values, otherwise a SELECT will be added.\n  if (hasValues || !hasColumns) {\n    this.valueSets.push(values);\n  }\n  return self;\n};\n\n/*\n * Get parameters for all values to be inserted. This function\n * handles handles bulk inserts, where keys may be present\n * in some objects and not others. When keys are not present,\n * the insert should refer to the column value as DEFAULT.\n */\nInsert.prototype.getParameters = function () {\n  var self = this;\n  return this.valueSets.map(function (nodeDict) {\n    var set = [];\n    self.names.forEach(function (name) {\n      var node = nodeDict[name];\n      if (node) {\n        set.push(ParameterNode.getNodeOrParameterNode(node.value));\n      } else {\n        set.push(new DefaultNode());\n      }\n    });\n    return set;\n  });\n};","map":{"version":3,"names":["DefaultNode","require","Node","ParameterNode","Insert","define","type","constructor","call","names","columns","valueSets","module","exports","prototype","add","nodes","hasColumns","hasValues","self","values","forEach","node","column","toNode","name","idx","indexOf","push","value","undefined","getParameters","map","nodeDict","set","getNodeOrParameterNode"],"sources":["/home/ali/Documents/run_prj/happysnake/node_modules/sql/lib/node/insert.js"],"sourcesContent":["'use strict';\n\nvar DefaultNode   = require('./default');\nvar Node          = require('./');\nvar ParameterNode = require('./parameter');\n\nvar Insert = Node.define({\n  type: 'INSERT',\n  constructor: function () {\n    Node.call(this);\n    this.names = [];\n    this.columns = [];\n    this.valueSets = [];\n  }\n});\n\nmodule.exports = Insert;\n\nInsert.prototype.add = function (nodes) {\n  var hasColumns = false;\n  var hasValues = false;\n  var self = this;\n  var values = {};\n  nodes.forEach(function (node) {\n    var column = node.toNode();\n    var name = column.name;\n    var idx = self.names.indexOf(name);\n    if (idx < 0) {\n      self.names.push(name);\n      self.columns.push(column);\n    }\n    hasColumns = true;\n    hasValues = hasValues || column.value !== undefined;\n    values[name] = column;\n  });\n\n  // When none of the columns have a value, it's ambiguous whether the user\n  // intends to insert a row of default values or append a SELECT statement\n  // later.  Resolve the ambiguity by assuming that if no columns are specified\n  // it is a row of default values, otherwise a SELECT will be added.\n  if (hasValues || !hasColumns) {\n    this.valueSets.push(values);\n  }\n\n  return self;\n};\n\n/*\n * Get parameters for all values to be inserted. This function\n * handles handles bulk inserts, where keys may be present\n * in some objects and not others. When keys are not present,\n * the insert should refer to the column value as DEFAULT.\n */\nInsert.prototype.getParameters = function () {\n  var self = this;\n  return this.valueSets\n    .map(function (nodeDict) {\n      var set = [];\n      self.names.forEach(function (name) {\n        var node = nodeDict[name];\n        if (node) {\n          set.push(ParameterNode.getNodeOrParameterNode(node.value));\n        }\n        else {\n          set.push(new DefaultNode());\n        }\n      });\n      return set;\n    });\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,WAAW,GAAKC,OAAO,CAAC,WAAW,CAAC;AACxC,IAAIC,IAAI,GAAYD,OAAO,CAAC,IAAI,CAAC;AACjC,IAAIE,aAAa,GAAGF,OAAO,CAAC,aAAa,CAAC;AAE1C,IAAIG,MAAM,GAAGF,IAAI,CAACG,MAAM,CAAC;EACvBC,IAAI,EAAE,QAAQ;EACdC,WAAW,EAAE,SAAAA,CAAA,EAAY;IACvBL,IAAI,CAACM,IAAI,CAAC,IAAI,CAAC;IACf,IAAI,CAACC,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,OAAO,GAAG,EAAE;IACjB,IAAI,CAACC,SAAS,GAAG,EAAE;EACrB;AACF,CAAC,CAAC;AAEFC,MAAM,CAACC,OAAO,GAAGT,MAAM;AAEvBA,MAAM,CAACU,SAAS,CAACC,GAAG,GAAG,UAAUC,KAAK,EAAE;EACtC,IAAIC,UAAU,GAAG,KAAK;EACtB,IAAIC,SAAS,GAAG,KAAK;EACrB,IAAIC,IAAI,GAAG,IAAI;EACf,IAAIC,MAAM,GAAG,CAAC,CAAC;EACfJ,KAAK,CAACK,OAAO,CAAC,UAAUC,IAAI,EAAE;IAC5B,IAAIC,MAAM,GAAGD,IAAI,CAACE,MAAM,CAAC,CAAC;IAC1B,IAAIC,IAAI,GAAGF,MAAM,CAACE,IAAI;IACtB,IAAIC,GAAG,GAAGP,IAAI,CAACV,KAAK,CAACkB,OAAO,CAACF,IAAI,CAAC;IAClC,IAAIC,GAAG,GAAG,CAAC,EAAE;MACXP,IAAI,CAACV,KAAK,CAACmB,IAAI,CAACH,IAAI,CAAC;MACrBN,IAAI,CAACT,OAAO,CAACkB,IAAI,CAACL,MAAM,CAAC;IAC3B;IACAN,UAAU,GAAG,IAAI;IACjBC,SAAS,GAAGA,SAAS,IAAIK,MAAM,CAACM,KAAK,KAAKC,SAAS;IACnDV,MAAM,CAACK,IAAI,CAAC,GAAGF,MAAM;EACvB,CAAC,CAAC;;EAEF;EACA;EACA;EACA;EACA,IAAIL,SAAS,IAAI,CAACD,UAAU,EAAE;IAC5B,IAAI,CAACN,SAAS,CAACiB,IAAI,CAACR,MAAM,CAAC;EAC7B;EAEA,OAAOD,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAf,MAAM,CAACU,SAAS,CAACiB,aAAa,GAAG,YAAY;EAC3C,IAAIZ,IAAI,GAAG,IAAI;EACf,OAAO,IAAI,CAACR,SAAS,CAClBqB,GAAG,CAAC,UAAUC,QAAQ,EAAE;IACvB,IAAIC,GAAG,GAAG,EAAE;IACZf,IAAI,CAACV,KAAK,CAACY,OAAO,CAAC,UAAUI,IAAI,EAAE;MACjC,IAAIH,IAAI,GAAGW,QAAQ,CAACR,IAAI,CAAC;MACzB,IAAIH,IAAI,EAAE;QACRY,GAAG,CAACN,IAAI,CAACzB,aAAa,CAACgC,sBAAsB,CAACb,IAAI,CAACO,KAAK,CAAC,CAAC;MAC5D,CAAC,MACI;QACHK,GAAG,CAACN,IAAI,CAAC,IAAI5B,WAAW,CAAC,CAAC,CAAC;MAC7B;IACF,CAAC,CAAC;IACF,OAAOkC,GAAG;EACZ,CAAC,CAAC;AACN,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}