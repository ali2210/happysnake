{"ast":null,"code":"//See: https://github.com/ethereum/wiki/wiki/RLP\nimport { hexlify } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\nimport { getBytes } from \"./data.js\";\nfunction hexlifyByte(value) {\n  var result = value.toString(16);\n  while (result.length < 2) {\n    result = \"0\" + result;\n  }\n  return \"0x\" + result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n  var result = 0;\n  for (var i = 0; i < length; i++) {\n    result = result * 256 + data[offset + i];\n  }\n  return result;\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n  var result = [];\n  while (childOffset < offset + 1 + length) {\n    var decoded = _decode(data, childOffset);\n    result.push(decoded.result);\n    childOffset += decoded.consumed;\n    assert(childOffset <= offset + 1 + length, \"child data too short\", \"BUFFER_OVERRUN\", {\n      buffer: data,\n      length: length,\n      offset: offset\n    });\n  }\n  return {\n    consumed: 1 + length,\n    result: result\n  };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n  assert(data.length !== 0, \"data too short\", \"BUFFER_OVERRUN\", {\n    buffer: data,\n    length: 0,\n    offset: 1\n  });\n  var checkOffset = function checkOffset(offset) {\n    assert(offset <= data.length, \"data short segment too short\", \"BUFFER_OVERRUN\", {\n      buffer: data,\n      length: data.length,\n      offset: offset\n    });\n  };\n  // Array with extra length prefix\n  if (data[offset] >= 0xf8) {\n    var lengthLength = data[offset] - 0xf7;\n    checkOffset(offset + 1 + lengthLength);\n    var length = unarrayifyInteger(data, offset + 1, lengthLength);\n    checkOffset(offset + 1 + lengthLength + length);\n    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n  } else if (data[offset] >= 0xc0) {\n    var _length = data[offset] - 0xc0;\n    checkOffset(offset + 1 + _length);\n    return _decodeChildren(data, offset, offset + 1, _length);\n  } else if (data[offset] >= 0xb8) {\n    var _lengthLength = data[offset] - 0xb7;\n    checkOffset(offset + 1 + _lengthLength);\n    var _length2 = unarrayifyInteger(data, offset + 1, _lengthLength);\n    checkOffset(offset + 1 + _lengthLength + _length2);\n    var result = hexlify(data.slice(offset + 1 + _lengthLength, offset + 1 + _lengthLength + _length2));\n    return {\n      consumed: 1 + _lengthLength + _length2,\n      result: result\n    };\n  } else if (data[offset] >= 0x80) {\n    var _length3 = data[offset] - 0x80;\n    checkOffset(offset + 1 + _length3);\n    var _result = hexlify(data.slice(offset + 1, offset + 1 + _length3));\n    return {\n      consumed: 1 + _length3,\n      result: _result\n    };\n  }\n  return {\n    consumed: 1,\n    result: hexlifyByte(data[offset])\n  };\n}\n/**\n *  Decodes %%data%% into the structured data it represents.\n */\nexport function decodeRlp(_data) {\n  var data = getBytes(_data, \"data\");\n  var decoded = _decode(data, 0);\n  assertArgument(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n  return decoded.result;\n}","map":null,"metadata":{},"sourceType":"module"}