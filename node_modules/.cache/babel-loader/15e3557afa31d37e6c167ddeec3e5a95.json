{"ast":null,"code":"import _classCallCheck from \"/home/ali/Documents/run_prj/happysnake/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/ali/Documents/run_prj/happysnake/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { ZeroHash } from \"../constants/index.js\";\nimport { concat, dataLength, getBigInt, getBytes, getNumber, hexlify, toBeArray, isHexString, zeroPadValue, assertArgument, assertPrivate } from \"../utils/index.js\";\n// Constants\nvar BN_0 = BigInt(0);\nvar BN_1 = BigInt(1);\nvar BN_2 = BigInt(2);\nvar BN_27 = BigInt(27);\nvar BN_28 = BigInt(28);\nvar BN_35 = BigInt(35);\nvar _guard = {};\nfunction toUint256(value) {\n  return zeroPadValue(toBeArray(value), 32);\n}\n/**\n *  A Signature  @TODO\n *\n *\n *  @_docloc: api/crypto:Signing\n */\nexport var Signature = /*#__PURE__*/function () {\n  _createClass(Signature, [{\n    key: \"r\",\n    /**\n     *  The ``r`` value for a signautre.\n     *\n     *  This represents the ``x`` coordinate of a \"reference\" or\n     *  challenge point, from which the ``y`` can be computed.\n     */\n    get: function get() {\n      return this.#r;\n    },\n    set: function set(value) {\n      assertArgument(dataLength(value) === 32, \"invalid r\", \"value\", value);\n      this.#r = hexlify(value);\n    }\n    /**\n     *  The ``s`` value for a signature.\n     */\n  }, {\n    key: \"s\",\n    get: function get() {\n      return this.#s;\n    },\n    set: function set(_value) {\n      assertArgument(dataLength(_value) === 32, \"invalid s\", \"value\", _value);\n      var value = hexlify(_value);\n      assertArgument(parseInt(value.substring(0, 3)) < 8, \"non-canonical s\", \"value\", value);\n      this.#s = value;\n    }\n    /**\n     *  The ``v`` value for a signature.\n     *\n     *  Since a given ``x`` value for ``r`` has two possible values for\n     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``\n     *  values to use.\n     *\n     *  It is normalized to the values ``27`` or ``28`` for legacy\n     *  purposes.\n     */\n  }, {\n    key: \"v\",\n    get: function get() {\n      return this.#v;\n    },\n    set: function set(value) {\n      var v = getNumber(value, \"value\");\n      assertArgument(v === 27 || v === 28, \"invalid v\", \"v\", value);\n      this.#v = v;\n    }\n    /**\n     *  The EIP-155 ``v`` for legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */\n  }, {\n    key: \"networkV\",\n    get: function get() {\n      return this.#networkV;\n    }\n    /**\n     *  The chain ID for EIP-155 legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */\n  }, {\n    key: \"legacyChainId\",\n    get: function get() {\n      var v = this.networkV;\n      if (v == null) {\n        return null;\n      }\n      return Signature.getChainId(v);\n    }\n    /**\n     *  The ``yParity`` for the signature.\n     *\n     *  See ``v`` for more details on how this value is used.\n     */\n  }, {\n    key: \"yParity\",\n    get: function get() {\n      return this.v === 27 ? 0 : 1;\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation of the ``yParity``\n     *  and ``s`` compacted into a single ``bytes32``.\n     */\n  }, {\n    key: \"yParityAndS\",\n    get: function get() {\n      // The EIP-2098 compact representation\n      var yParityAndS = getBytes(this.s);\n      if (this.yParity) {\n        yParityAndS[0] |= 0x80;\n      }\n      return hexlify(yParityAndS);\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation.\n     */\n  }, {\n    key: \"compactSerialized\",\n    get: function get() {\n      return concat([this.r, this.yParityAndS]);\n    }\n    /**\n     *  The serialized representation.\n     */\n  }, {\n    key: \"serialized\",\n    get: function get() {\n      return concat([this.r, this.s, this.yParity ? \"0x1c\" : \"0x1b\"]);\n    }\n    /**\n     *  @private\n     */\n  }]);\n  function Signature(guard, r, s, v) {\n    _classCallCheck(this, Signature);\n    assertPrivate(guard, _guard, \"Signature\");\n    this.#r = r;\n    this.#s = s;\n    this.#v = v;\n    this.#networkV = null;\n  }\n  _createClass(Signature, [{\n    key: Symbol.for('nodejs.util.inspect.custom'),\n    value: function value() {\n      return \"Signature { r: \\\"\".concat(this.r, \"\\\", s: \\\"\").concat(this.s, \"\\\", yParity: \").concat(this.yParity, \", networkV: \").concat(this.networkV, \" }\");\n    }\n    /**\n     *  Returns a new identical [[Signature]].\n     */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var clone = new Signature(_guard, this.r, this.s, this.v);\n      if (this.networkV) {\n        clone.#networkV = this.networkV;\n      }\n      return clone;\n    }\n    /**\n     *  Returns a representation that is compatible with ``JSON.stringify``.\n     */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var networkV = this.networkV;\n      return {\n        _type: \"signature\",\n        networkV: networkV != null ? networkV.toString() : null,\n        r: this.r,\n        s: this.s,\n        v: this.v\n      };\n    }\n    /**\n     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.\n     *\n     *  @example:\n     *    Signature.getChainId(45)\n     *    //_result:\n     *\n     *    Signature.getChainId(46)\n     *    //_result:\n     */\n  }], [{\n    key: \"getChainId\",\n    value: function getChainId(v) {\n      var bv = getBigInt(v, \"v\");\n      // The v is not an EIP-155 v, so it is the unspecified chain ID\n      if (bv == BN_27 || bv == BN_28) {\n        return BN_0;\n      }\n      // Bad value for an EIP-155 v\n      assertArgument(bv >= BN_35, \"invalid EIP-155 v\", \"v\", v);\n      return (bv - BN_35) / BN_2;\n    }\n    /**\n     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.\n     *\n     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``\n     *  property to include the chain ID.\n     *\n     *  @example:\n     *    Signature.getChainIdV(5, 27)\n     *    //_result:\n     *\n     *    Signature.getChainIdV(5, 28)\n     *    //_result:\n     *\n     */\n  }, {\n    key: \"getChainIdV\",\n    value: function getChainIdV(chainId, v) {\n      return getBigInt(chainId) * BN_2 + BigInt(35 + v - 27);\n    }\n    /**\n     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,\n     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.\n     *\n     *  @example:\n     *    // The values 0 and 1 imply v is actually yParity\n     *    Signature.getNormalizedV(0)\n     *    //_result:\n     *\n     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)\n     *    Signature.getNormalizedV(27)\n     *    //_result:\n     *\n     *    // Legacy EIP-155 transaction (i.e. >= 35)\n     *    Signature.getNormalizedV(46)\n     *    //_result:\n     *\n     *    // Invalid values throw\n     *    Signature.getNormalizedV(5)\n     *    //_error:\n     */\n  }, {\n    key: \"getNormalizedV\",\n    value: function getNormalizedV(v) {\n      var bv = getBigInt(v);\n      if (bv === BN_0 || bv === BN_27) {\n        return 27;\n      }\n      if (bv === BN_1 || bv === BN_28) {\n        return 28;\n      }\n      assertArgument(bv >= BN_35, \"invalid v\", \"v\", v);\n      // Otherwise, EIP-155 v means odd is 27 and even is 28\n      return bv & BN_1 ? 27 : 28;\n    }\n    /**\n     *  Creates a new [[Signature]].\n     *\n     *  If no %%sig%% is provided, a new [[Signature]] is created\n     *  with default values.\n     *\n     *  If %%sig%% is a string, it is parsed.\n     */\n  }, {\n    key: \"from\",\n    value: function from(sig) {\n      function assertError(check, message) {\n        assertArgument(check, message, \"signature\", sig);\n      }\n      ;\n      if (sig == null) {\n        return new Signature(_guard, ZeroHash, ZeroHash, 27);\n      }\n      if (typeof sig === \"string\") {\n        var bytes = getBytes(sig, \"signature\");\n        if (bytes.length === 64) {\n          var _r2 = hexlify(bytes.slice(0, 32));\n          var _s = bytes.slice(32, 64);\n          var _v2 = _s[0] & 0x80 ? 28 : 27;\n          _s[0] &= 0x7f;\n          return new Signature(_guard, _r2, hexlify(_s), _v2);\n        }\n        if (bytes.length === 65) {\n          var _r3 = hexlify(bytes.slice(0, 32));\n          var _s2 = bytes.slice(32, 64);\n          assertError((_s2[0] & 0x80) === 0, \"non-canonical s\");\n          var _v3 = Signature.getNormalizedV(bytes[64]);\n          return new Signature(_guard, _r3, hexlify(_s2), _v3);\n        }\n        assertError(false, \"invalid raw signature length\");\n      }\n      if (sig instanceof Signature) {\n        return sig.clone();\n      }\n      // Get r\n      var _r = sig.r;\n      assertError(_r != null, \"missing r\");\n      var r = toUint256(_r);\n      // Get s; by any means necessary (we check consistency below)\n      var s = function (s, yParityAndS) {\n        if (s != null) {\n          return toUint256(s);\n        }\n        if (yParityAndS != null) {\n          assertError(isHexString(yParityAndS, 32), \"invalid yParityAndS\");\n          var _bytes = getBytes(yParityAndS);\n          _bytes[0] &= 0x7f;\n          return hexlify(_bytes);\n        }\n        assertError(false, \"missing s\");\n      }(sig.s, sig.yParityAndS);\n      assertError((getBytes(s)[0] & 0x80) == 0, \"non-canonical s\");\n      // Get v; by any means necessary (we check consistency below)\n      var _ref = function (_v, yParityAndS, yParity) {\n          if (_v != null) {\n            var _v4 = getBigInt(_v);\n            return {\n              networkV: _v4 >= BN_35 ? _v4 : undefined,\n              v: Signature.getNormalizedV(_v4)\n            };\n          }\n          if (yParityAndS != null) {\n            assertError(isHexString(yParityAndS, 32), \"invalid yParityAndS\");\n            return {\n              v: getBytes(yParityAndS)[0] & 0x80 ? 28 : 27\n            };\n          }\n          if (yParity != null) {\n            switch (yParity) {\n              case 0:\n                return {\n                  v: 27\n                };\n              case 1:\n                return {\n                  v: 28\n                };\n            }\n            assertError(false, \"invalid yParity\");\n          }\n          assertError(false, \"missing v\");\n        }(sig.v, sig.yParityAndS, sig.yParity),\n        networkV = _ref.networkV,\n        v = _ref.v;\n      var result = new Signature(_guard, r, s, v);\n      if (networkV) {\n        result.#networkV = networkV;\n      }\n      // If multiple of v, yParity, yParityAndS we given, check they match\n      assertError(!(\"yParity\" in sig && sig.yParity !== result.yParity), \"yParity mismatch\");\n      assertError(!(\"yParityAndS\" in sig && sig.yParityAndS !== result.yParityAndS), \"yParityAndS mismatch\");\n      return result;\n    }\n  }]);\n  return Signature;\n}();","map":null,"metadata":{},"sourceType":"module"}