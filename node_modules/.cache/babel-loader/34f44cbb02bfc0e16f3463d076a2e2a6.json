{"ast":null,"code":"import _classCallCheck from \"/home/ali/Documents/run_prj/happysnake/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/ali/Documents/run_prj/happysnake/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _asyncToGenerator from \"/home/ali/Documents/run_prj/happysnake/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n/**\n *  Fetching content from the web is environment-specific, so Ethers\n *  provides an abstraction the each environment can implement to provide\n *  this service.\n *\n *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to\n *  create a request object, register event listeners and process data\n *  and populate the [[FetchResponse]].\n *\n *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting\n *  ``Promise`` is waited on to retreive the payload.\n *\n *  The [[FetchRequest]] is responsible for handling many common situations,\n *  such as redirects, server throttling, authentcation, etc.\n *\n *  It also handles common gateways, such as IPFS and data URIs.\n *\n *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]\n */\nimport { decodeBase64, encodeBase64 } from \"./base64.js\";\nimport { hexlify } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\nimport { defineProperties } from \"./properties.js\";\nimport { toUtf8Bytes, toUtf8String } from \"./utf8.js\";\nimport { getUrl } from \"./geturl.js\";\nvar MAX_ATTEMPTS = 12;\nvar SLOT_INTERVAL = 250;\n// The global FetchGetUrlFunc implementation.\nvar getUrlFunc = getUrl;\nvar reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\nvar reIpfs = new RegExp(\"^ipfs:/\\/(ipfs/)?(.*)$\", \"i\");\n// If locked, new Gateways cannot be added\nvar locked = false;\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs\nfunction dataGatewayFunc(_x, _x2) {\n  return _dataGatewayFunc.apply(this, arguments);\n}\n/**\n *  Returns a [[FetchGatewayFunc]] for fetching content from a standard\n *  IPFS gateway hosted at %%baseUrl%%.\n */\nfunction _dataGatewayFunc() {\n  _dataGatewayFunc = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(url, signal) {\n    var match;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.prev = 0;\n          match = url.match(reData);\n          if (match) {\n            _context2.next = 4;\n            break;\n          }\n          throw new Error(\"invalid data\");\n        case 4:\n          return _context2.abrupt(\"return\", new FetchResponse(200, \"OK\", {\n            \"content-type\": match[1] || \"text/plain\"\n          }, match[2] ? decodeBase64(match[3]) : unpercent(match[3])));\n        case 7:\n          _context2.prev = 7;\n          _context2.t0 = _context2[\"catch\"](0);\n          return _context2.abrupt(\"return\", new FetchResponse(599, \"BAD REQUEST (invalid data: URI)\", {}, null, new FetchRequest(url)));\n        case 10:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[0, 7]]);\n  }));\n  return _dataGatewayFunc.apply(this, arguments);\n}\nfunction getIpfsGatewayFunc(baseUrl) {\n  function gatewayIpfs(_x3, _x4) {\n    return _gatewayIpfs.apply(this, arguments);\n  }\n  function _gatewayIpfs() {\n    _gatewayIpfs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(url, signal) {\n      var match;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            match = url.match(reIpfs);\n            if (match) {\n              _context.next = 4;\n              break;\n            }\n            throw new Error(\"invalid link\");\n          case 4:\n            return _context.abrupt(\"return\", new FetchRequest(\"\".concat(baseUrl).concat(match[2])));\n          case 7:\n            _context.prev = 7;\n            _context.t0 = _context[\"catch\"](0);\n            return _context.abrupt(\"return\", new FetchResponse(599, \"BAD REQUEST (invalid IPFS URI)\", {}, null, new FetchRequest(url)));\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[0, 7]]);\n    }));\n    return _gatewayIpfs.apply(this, arguments);\n  }\n  return gatewayIpfs;\n}\nvar Gateways = {\n  \"data\": dataGatewayFunc,\n  \"ipfs\": getIpfsGatewayFunc(\"https:/\\/gateway.ipfs.io/ipfs/\")\n};\nvar fetchSignals = new WeakMap();\n/**\n *  @_ignore\n */\nexport var FetchCancelSignal = /*#__PURE__*/function () {\n  function FetchCancelSignal(request) {\n    var _this = this;\n    _classCallCheck(this, FetchCancelSignal);\n    this.#listeners = [];\n    this.#cancelled = false;\n    fetchSignals.set(request, function () {\n      if (_this.#cancelled) {\n        return;\n      }\n      _this.#cancelled = true;\n      var _iterator = _createForOfIteratorHelper(_this.#listeners),\n        _step;\n      try {\n        var _loop = function _loop() {\n          var listener = _step.value;\n          setTimeout(function () {\n            listener();\n          }, 0);\n        };\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      _this.#listeners = [];\n    });\n  }\n  _createClass(FetchCancelSignal, [{\n    key: \"addListener\",\n    value: function addListener(listener) {\n      assert(!this.#cancelled, \"singal already cancelled\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"fetchCancelSignal.addCancelListener\"\n      });\n      this.#listeners.push(listener);\n    }\n  }, {\n    key: \"checkSignal\",\n    value: function checkSignal() {\n      assert(!this.cancelled, \"cancelled\", \"CANCELLED\", {});\n    }\n  }, {\n    key: \"cancelled\",\n    get: function get() {\n      return this.#cancelled;\n    }\n  }]);\n  return FetchCancelSignal;\n}();\n// Check the signal, throwing if it is cancelled\nfunction checkSignal(signal) {\n  if (signal == null) {\n    throw new Error(\"missing signal; should not happen\");\n  }\n  signal.checkSignal();\n  return signal;\n}\n/**\n *  Represents a request for a resource using a URI.\n *\n *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\n *  and ``IPFS:``.\n *\n *  Additional schemes can be added globally using [[registerGateway]].\n *\n *  @example:\n *    req = new FetchRequest(\"https://www.ricmoo.com\")\n *    resp = await req.send()\n *    resp.body.length\n *    //_result:\n */\nexport var FetchRequest = /*#__PURE__*/function () {\n  _createClass(FetchRequest, [{\n    key: \"hasBody\",\n    /**\n     *  Returns true if the request has a body.\n     */\n    value: function hasBody() {\n      return this.#body != null;\n    }\n    /**\n     *  The HTTP method to use when requesting the URI. If no method\n     *  has been explicitly set, then ``GET`` is used if the body is\n     *  null and ``POST`` otherwise.\n     */\n  }, {\n    key: \"getHeader\",\n    /**\n     *  Get the header for %%key%%, ignoring case.\n     */\n    value: function getHeader(key) {\n      return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Set the header for %%key%% to %%value%%. All values are coerced\n     *  to a string.\n     */\n  }, {\n    key: \"setHeader\",\n    value: function setHeader(key, value) {\n      this.#headers[String(key).toLowerCase()] = String(value);\n    }\n    /**\n     *  Clear all headers, resetting all intrinsic headers.\n     */\n  }, {\n    key: \"clearHeaders\",\n    value: function clearHeaders() {\n      this.#headers = {};\n    }\n  }, {\n    key: Symbol.iterator,\n    value: function value() {\n      var headers = this.headers;\n      var keys = Object.keys(headers);\n      var index = 0;\n      return {\n        next: function next() {\n          if (index < keys.length) {\n            var key = keys[index++];\n            return {\n              value: [key, headers[key]],\n              done: false\n            };\n          }\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      };\n    }\n    /**\n     *  The value that will be sent for the ``Authorization`` header.\n     *\n     *  To set the credentials, use the ``setCredentials`` method.\n     */\n  }, {\n    key: \"setCredentials\",\n    /**\n     *  Sets an ``Authorization`` for %%username%% with %%password%%.\n     */\n    value: function setCredentials(username, password) {\n      assertArgument(!username.match(/:/), \"invalid basic authentication username\", \"username\", \"[REDACTED]\");\n      this.#creds = \"\".concat(username, \":\").concat(password);\n    }\n    /**\n     *  Enable and request gzip-encoded responses. The response will\n     *  automatically be decompressed. //(default: true)//\n     */\n  }, {\n    key: \"url\",\n    /**\n     *  The fetch URI to requrest.\n     */\n    get: function get() {\n      return this.#url;\n    },\n    set: function set(url) {\n      this.#url = String(url);\n    }\n    /**\n     *  The fetch body, if any, to send as the request body. //(default: null)//\n     *\n     *  When setting a body, the intrinsic ``Content-Type`` is automatically\n     *  set and will be used if **not overridden** by setting a custom\n     *  header.\n     *\n     *  If %%body%% is null, the body is cleared (along with the\n     *  intrinsic ``Content-Type``) and the .\n     *\n     *  If %%body%% is a string, the intrincis ``Content-Type`` is set to\n     *  ``text/plain``.\n     *\n     *  If %%body%% is a Uint8Array, the intrincis ``Content-Type`` is set to\n     *  ``application/octet-stream``.\n     *\n     *  If %%body%% is any other object, the intrincis ``Content-Type`` is\n     *  set to ``application/json``.\n     */\n  }, {\n    key: \"body\",\n    get: function get() {\n      if (this.#body == null) {\n        return null;\n      }\n      return new Uint8Array(this.#body);\n    },\n    set: function set(body) {\n      if (body == null) {\n        this.#body = undefined;\n        this.#bodyType = undefined;\n      } else if (typeof body === \"string\") {\n        this.#body = toUtf8Bytes(body);\n        this.#bodyType = \"text/plain\";\n      } else if (body instanceof Uint8Array) {\n        this.#body = body;\n        this.#bodyType = \"application/octet-stream\";\n      } else if (typeof body === \"object\") {\n        this.#body = toUtf8Bytes(JSON.stringify(body));\n        this.#bodyType = \"application/json\";\n      } else {\n        throw new Error(\"invalid body\");\n      }\n    }\n  }, {\n    key: \"method\",\n    get: function get() {\n      if (this.#method) {\n        return this.#method;\n      }\n      if (this.hasBody()) {\n        return \"POST\";\n      }\n      return \"GET\";\n    },\n    set: function set(method) {\n      if (method == null) {\n        method = \"\";\n      }\n      this.#method = String(method).toUpperCase();\n    }\n    /**\n     *  The headers that will be used when requesting the URI. All\n     *  keys are lower-case.\n     *\n     *  This object is a copy, so any chnages will **NOT** be reflected\n     *  in the ``FetchRequest``.\n     *\n     *  To set a header entry, use the ``setHeader`` method.\n     */\n  }, {\n    key: \"headers\",\n    get: function get() {\n      var headers = Object.assign({}, this.#headers);\n      if (this.#creds) {\n        headers[\"authorization\"] = \"Basic \".concat(encodeBase64(toUtf8Bytes(this.#creds)));\n      }\n      ;\n      if (this.allowGzip) {\n        headers[\"accept-encoding\"] = \"gzip\";\n      }\n      if (headers[\"content-type\"] == null && this.#bodyType) {\n        headers[\"content-type\"] = this.#bodyType;\n      }\n      if (this.body) {\n        headers[\"content-length\"] = String(this.body.length);\n      }\n      return headers;\n    }\n  }, {\n    key: \"credentials\",\n    get: function get() {\n      return this.#creds || null;\n    }\n  }, {\n    key: \"allowGzip\",\n    get: function get() {\n      return this.#gzip;\n    },\n    set: function set(value) {\n      this.#gzip = !!value;\n    }\n    /**\n     *  Allow ``Authentication`` credentials to be sent over insecure\n     *  channels. //(default: false)//\n     */\n  }, {\n    key: \"allowInsecureAuthentication\",\n    get: function get() {\n      return !!this.#allowInsecure;\n    },\n    set: function set(value) {\n      this.#allowInsecure = !!value;\n    }\n    /**\n     *  The timeout (in milliseconds) to wait for a complere response.\n     *  //(default: 5 minutes)//\n     */\n  }, {\n    key: \"timeout\",\n    get: function get() {\n      return this.#timeout;\n    },\n    set: function set(timeout) {\n      assertArgument(timeout >= 0, \"timeout must be non-zero\", \"timeout\", timeout);\n      this.#timeout = timeout;\n    }\n    /**\n     *  This function is called prior to each request, for example\n     *  during a redirection or retry in case of server throttling.\n     *\n     *  This offers an opportunity to populate headers or update\n     *  content before sending a request.\n     */\n  }, {\n    key: \"preflightFunc\",\n    get: function get() {\n      return this.#preflight || null;\n    },\n    set: function set(preflight) {\n      this.#preflight = preflight;\n    }\n    /**\n     *  This function is called after each response, offering an\n     *  opportunity to provide client-level throttling or updating\n     *  response data.\n     *\n     *  Any error thrown in this causes the ``send()`` to throw.\n     *\n     *  To schedule a retry attempt (assuming the maximum retry limit\n     *  has not been reached), use [[response.throwThrottleError]].\n     */\n  }, {\n    key: \"processFunc\",\n    get: function get() {\n      return this.#process || null;\n    },\n    set: function set(process) {\n      this.#process = process;\n    }\n    /**\n     *  This function is called on each retry attempt.\n     */\n  }, {\n    key: \"retryFunc\",\n    get: function get() {\n      return this.#retry || null;\n    },\n    set: function set(retry) {\n      this.#retry = retry;\n    }\n    /**\n     *  Create a new FetchRequest instance with default values.\n     *\n     *  Once created, each property may be set before issuing a\n     *  ``.send()`` to make the request.\n     */\n  }]);\n  function FetchRequest(url) {\n    _classCallCheck(this, FetchRequest);\n    this.#url = String(url);\n    this.#allowInsecure = false;\n    this.#gzip = true;\n    this.#headers = {};\n    this.#method = \"\";\n    this.#timeout = 300000;\n    this.#throttle = {\n      slotInterval: SLOT_INTERVAL,\n      maxAttempts: MAX_ATTEMPTS\n    };\n  }\n  _createClass(FetchRequest, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"<FetchRequest method=\".concat(JSON.stringify(this.method), \" url=\").concat(JSON.stringify(this.url), \" headers=\").concat(JSON.stringify(this.headers), \" body=\").concat(this.#body ? hexlify(this.#body) : \"null\", \">\");\n    }\n    /**\n     *  Update the throttle parameters used to determine maximum\n     *  attempts and exponential-backoff properties.\n     */\n  }, {\n    key: \"setThrottleParams\",\n    value: function setThrottleParams(params) {\n      if (params.slotInterval != null) {\n        this.#throttle.slotInterval = params.slotInterval;\n      }\n      if (params.maxAttempts != null) {\n        this.#throttle.maxAttempts = params.maxAttempts;\n      }\n    }\n  }, {\n    key: \"send\",\n    /**\n     *  Resolves to the response by sending the request.\n     */\n    value: function send() {\n      assert(this.#signal == null, \"request already sent\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"fetchRequest.send\"\n      });\n      this.#signal = new FetchCancelSignal(this);\n      return this.#send(0, getTime() + this.timeout, 0, this, new FetchResponse(0, \"\", {}, null, this));\n    }\n    /**\n     *  Cancels the inflight response, causing a ``CANCELLED``\n     *  error to be rejected from the [[send]].\n     */\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      assert(this.#signal != null, \"request has not been sent\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"fetchRequest.cancel\"\n      });\n      var signal = fetchSignals.get(this);\n      if (!signal) {\n        throw new Error(\"missing signal; should not happen\");\n      }\n      signal();\n    }\n    /**\n     *  Returns a new [[FetchRequest]] that represents the redirection\n     *  to %%location%%.\n     */\n  }, {\n    key: \"redirect\",\n    value: function redirect(location) {\n      // Redirection; for now we only support absolute locataions\n      var current = this.url.split(\":\")[0].toLowerCase();\n      var target = location.split(\":\")[0].toLowerCase();\n      // Don't allow redirecting:\n      // - non-GET requests\n      // - downgrading the security (e.g. https => http)\n      // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]\n      assert(this.method === \"GET\" && (current !== \"https\" || target !== \"http\") && location.match(/^https?:/), \"unsupported redirect\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"redirect(\".concat(this.method, \" \").concat(JSON.stringify(this.url), \" => \").concat(JSON.stringify(location), \")\")\n      });\n      // Create a copy of this request, with a new URL\n      var req = new FetchRequest(location);\n      req.method = \"GET\";\n      req.allowGzip = this.allowGzip;\n      req.timeout = this.timeout;\n      req.#headers = Object.assign({}, this.#headers);\n      if (this.#body) {\n        req.#body = new Uint8Array(this.#body);\n      }\n      req.#bodyType = this.#bodyType;\n      // Do not forward credentials unless on the same domain; only absolute\n      //req.allowInsecure = false;\n      // paths are currently supported; may want a way to specify to forward?\n      //setStore(req.#props, \"creds\", getStore(this.#pros, \"creds\"));\n      return req;\n    }\n    /**\n     *  Create a new copy of this request.\n     */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var clone = new FetchRequest(this.url);\n      // Preserve \"default method\" (i.e. null)\n      clone.#method = this.#method;\n      // Preserve \"default body\" with type, copying the Uint8Array is present\n      if (this.#body) {\n        clone.#body = this.#body;\n      }\n      clone.#bodyType = this.#bodyType;\n      // Preserve \"default headers\"\n      clone.#headers = Object.assign({}, this.#headers);\n      // Credentials is readonly, so we copy internally\n      clone.#creds = this.#creds;\n      if (this.allowGzip) {\n        clone.allowGzip = true;\n      }\n      clone.timeout = this.timeout;\n      if (this.allowInsecureAuthentication) {\n        clone.allowInsecureAuthentication = true;\n      }\n      clone.#preflight = this.#preflight;\n      clone.#process = this.#process;\n      clone.#retry = this.#retry;\n      return clone;\n    }\n    /**\n     *  Locks all static configuration for gateways and FetchGetUrlFunc\n     *  registration.\n     */\n  }], [{\n    key: \"lockConfig\",\n    value: function lockConfig() {\n      locked = true;\n    }\n    /**\n     *  Get the current Gateway function for %%scheme%%.\n     */\n  }, {\n    key: \"getGateway\",\n    value: function getGateway(scheme) {\n      return Gateways[scheme.toLowerCase()] || null;\n    }\n    /**\n     *  Use the %%func%% when fetching URIs using %%scheme%%.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */\n  }, {\n    key: \"registerGateway\",\n    value: function registerGateway(scheme, func) {\n      scheme = scheme.toLowerCase();\n      if (scheme === \"http\" || scheme === \"https\") {\n        throw new Error(\"cannot intercept \".concat(scheme, \"; use registerGetUrl\"));\n      }\n      if (locked) {\n        throw new Error(\"gateways locked\");\n      }\n      Gateways[scheme] = func;\n    }\n    /**\n     *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */\n  }, {\n    key: \"registerGetUrl\",\n    value: function registerGetUrl(getUrl) {\n      if (locked) {\n        throw new Error(\"gateways locked\");\n      }\n      getUrlFunc = getUrl;\n    }\n    /**\n     *  Creates a function that can \"fetch\" data URIs.\n     *\n     *  Note that this is automatically done internally to support\n     *  data URIs, so it is not necessary to register it.\n     *\n     *  This is not generally something that is needed, but may\n     *  be useful in a wrapper to perfom custom data URI functionality.\n     */\n  }, {\n    key: \"createDataGateway\",\n    value: function createDataGateway() {\n      return dataGatewayFunc;\n    }\n    /**\n     *  Creates a function that will fetch IPFS (unvalidated) from\n     *  a custom gateway baseUrl.\n     *\n     *  The default IPFS gateway used internally is\n     *  ``\"https:/\\/gateway.ipfs.io/ipfs/\"``.\n     */\n  }, {\n    key: \"createIpfsGatewayFunc\",\n    value: function createIpfsGatewayFunc(baseUrl) {\n      return getIpfsGatewayFunc(baseUrl);\n    }\n  }]);\n  return FetchRequest;\n}();\n;\n/**\n *  The response for a FetchREquest.\n */\nexport var FetchResponse = /*#__PURE__*/function () {\n  _createClass(FetchResponse, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"<FetchResponse status=\".concat(this.statusCode, \" body=\").concat(this.#body ? hexlify(this.#body) : \"null\", \">\");\n    }\n    /**\n     *  The response status code.\n     */\n  }, {\n    key: Symbol.iterator,\n    value: function value() {\n      var headers = this.headers;\n      var keys = Object.keys(headers);\n      var index = 0;\n      return {\n        next: function next() {\n          if (index < keys.length) {\n            var key = keys[index++];\n            return {\n              value: [key, headers[key]],\n              done: false\n            };\n          }\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      };\n    }\n  }, {\n    key: \"statusCode\",\n    get: function get() {\n      return this.#statusCode;\n    }\n    /**\n     *  The response status message.\n     */\n  }, {\n    key: \"statusMessage\",\n    get: function get() {\n      return this.#statusMessage;\n    }\n    /**\n     *  The response headers. All keys are lower-case.\n     */\n  }, {\n    key: \"headers\",\n    get: function get() {\n      return Object.assign({}, this.#headers);\n    }\n    /**\n     *  The response body, or ``null`` if there was no body.\n     */\n  }, {\n    key: \"body\",\n    get: function get() {\n      return this.#body == null ? null : new Uint8Array(this.#body);\n    }\n    /**\n     *  The response body as a UTF-8 encoded string, or the empty\n     *  string (i.e. ``\"\"``) if there was no body.\n     *\n     *  An error is thrown if the body is invalid UTF-8 data.\n     */\n  }, {\n    key: \"bodyText\",\n    get: function get() {\n      try {\n        return this.#body == null ? \"\" : toUtf8String(this.#body);\n      } catch (error) {\n        assert(false, \"response body is not valid UTF-8 data\", \"UNSUPPORTED_OPERATION\", {\n          operation: \"bodyText\",\n          info: {\n            response: this\n          }\n        });\n      }\n    }\n    /**\n     *  The response body, decoded as JSON.\n     *\n     *  An error is thrown if the body is invalid JSON-encoded data\n     *  or if there was no body.\n     */\n  }, {\n    key: \"bodyJson\",\n    get: function get() {\n      try {\n        return JSON.parse(this.bodyText);\n      } catch (error) {\n        assert(false, \"response body is not valid JSON\", \"UNSUPPORTED_OPERATION\", {\n          operation: \"bodyJson\",\n          info: {\n            response: this\n          }\n        });\n      }\n    }\n  }]);\n  function FetchResponse(statusCode, statusMessage, headers, body, request) {\n    _classCallCheck(this, FetchResponse);\n    this.#statusCode = statusCode;\n    this.#statusMessage = statusMessage;\n    this.#headers = Object.keys(headers).reduce(function (accum, k) {\n      accum[k.toLowerCase()] = String(headers[k]);\n      return accum;\n    }, {});\n    this.#body = body == null ? null : new Uint8Array(body);\n    this.#request = request || null;\n    this.#error = {\n      message: \"\"\n    };\n  }\n  /**\n   *  Return a Response with matching headers and body, but with\n   *  an error status code (i.e. 599) and %%message%% with an\n   *  optional %%error%%.\n   */\n  _createClass(FetchResponse, [{\n    key: \"makeServerError\",\n    value: function makeServerError(message, error) {\n      var statusMessage;\n      if (!message) {\n        message = \"\".concat(this.statusCode, \" \").concat(this.statusMessage);\n        statusMessage = \"CLIENT ESCALATED SERVER ERROR (\".concat(message, \")\");\n      } else {\n        statusMessage = \"CLIENT ESCALATED SERVER ERROR (\".concat(this.statusCode, \" \").concat(this.statusMessage, \"; \").concat(message, \")\");\n      }\n      var response = new FetchResponse(599, statusMessage, this.headers, this.body, this.#request || undefined);\n      response.#error = {\n        message: message,\n        error: error\n      };\n      return response;\n    }\n    /**\n     *  If called within a [request.processFunc](FetchRequest-processFunc)\n     *  call, causes the request to retry as if throttled for %%stall%%\n     *  milliseconds.\n     */\n  }, {\n    key: \"throwThrottleError\",\n    value: function throwThrottleError(message, stall) {\n      if (stall == null) {\n        stall = -1;\n      } else {\n        assertArgument(Number.isInteger(stall) && stall >= 0, \"invalid stall timeout\", \"stall\", stall);\n      }\n      var error = new Error(message || \"throttling requests\");\n      defineProperties(error, {\n        stall: stall,\n        throttle: true\n      });\n      throw error;\n    }\n    /**\n     *  Get the header value for %%key%%, ignoring case.\n     */\n  }, {\n    key: \"getHeader\",\n    value: function getHeader(key) {\n      return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Returns true of the response has a body.\n     */\n  }, {\n    key: \"hasBody\",\n    value: function hasBody() {\n      return this.#body != null;\n    }\n    /**\n     *  The request made for this response.\n     */\n  }, {\n    key: \"ok\",\n    /**\n     *  Returns true if this response was a success statusCode.\n     */\n    value: function ok() {\n      return this.#error.message === \"\" && this.statusCode >= 200 && this.statusCode < 300;\n    }\n    /**\n     *  Throws a ``SERVER_ERROR`` if this response is not ok.\n     */\n  }, {\n    key: \"assertOk\",\n    value: function assertOk() {\n      if (this.ok()) {\n        return;\n      }\n      var _this$error = this.#error,\n        message = _this$error.message,\n        error = _this$error.error;\n      if (message === \"\") {\n        message = \"server response \".concat(this.statusCode, \" \").concat(this.statusMessage);\n      }\n      assert(false, message, \"SERVER_ERROR\", {\n        request: this.request || \"unknown request\",\n        response: this,\n        error: error\n      });\n    }\n  }, {\n    key: \"request\",\n    get: function get() {\n      return this.#request;\n    }\n  }]);\n  return FetchResponse;\n}();\nfunction getTime() {\n  return new Date().getTime();\n}\nfunction unpercent(value) {\n  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, function (all, code) {\n    return String.fromCharCode(parseInt(code, 16));\n  }));\n}\nfunction wait(delay) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, delay);\n  });\n}","map":null,"metadata":{},"sourceType":"module"}