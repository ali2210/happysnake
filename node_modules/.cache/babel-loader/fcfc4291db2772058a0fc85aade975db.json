{"ast":null,"code":"import _classCallCheck from \"/home/ali/Documents/run_prj/happysnake/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/ali/Documents/run_prj/happysnake/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { getAddress } from \"../address/index.js\";\nimport { keccak256, Signature, SigningKey } from \"../crypto/index.js\";\nimport { concat, decodeRlp, encodeRlp, getBytes, getBigInt, getNumber, hexlify, assert, assertArgument, toBeArray, zeroPadValue } from \"../utils/index.js\";\nimport { accessListify } from \"./accesslist.js\";\nimport { recoverAddress } from \"./address.js\";\nvar BN_0 = BigInt(0);\nvar BN_2 = BigInt(2);\nvar BN_27 = BigInt(27);\nvar BN_28 = BigInt(28);\nvar BN_35 = BigInt(35);\nvar BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction handleAddress(value) {\n  if (value === \"0x\") {\n    return null;\n  }\n  return getAddress(value);\n}\nfunction handleAccessList(value, param) {\n  try {\n    return accessListify(value);\n  } catch (error) {\n    assertArgument(false, error.message, param, value);\n  }\n}\nfunction handleNumber(_value, param) {\n  if (_value === \"0x\") {\n    return 0;\n  }\n  return getNumber(_value, param);\n}\nfunction handleUint(_value, param) {\n  if (_value === \"0x\") {\n    return BN_0;\n  }\n  var value = getBigInt(_value, param);\n  assertArgument(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n  return value;\n}\nfunction formatNumber(_value, name) {\n  var value = getBigInt(_value, \"value\");\n  var result = toBeArray(value);\n  assertArgument(result.length <= 32, \"value too large\", \"tx.\".concat(name), value);\n  return result;\n}\nfunction formatAccessList(value) {\n  return accessListify(value).map(function (set) {\n    return [set.address, set.storageKeys];\n  });\n}\nfunction _parseLegacy(data) {\n  var fields = decodeRlp(data);\n  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), \"invalid field count for legacy transaction\", \"data\", data);\n  var tx = {\n    type: 0,\n    nonce: handleNumber(fields[0], \"nonce\"),\n    gasPrice: handleUint(fields[1], \"gasPrice\"),\n    gasLimit: handleUint(fields[2], \"gasLimit\"),\n    to: handleAddress(fields[3]),\n    value: handleUint(fields[4], \"value\"),\n    data: hexlify(fields[5]),\n    chainId: BN_0\n  };\n  // Legacy unsigned transaction\n  if (fields.length === 6) {\n    return tx;\n  }\n  var v = handleUint(fields[6], \"v\");\n  var r = handleUint(fields[7], \"r\");\n  var s = handleUint(fields[8], \"s\");\n  if (r === BN_0 && s === BN_0) {\n    // EIP-155 unsigned transaction\n    tx.chainId = v;\n  } else {\n    // Compute the EIP-155 chain ID (or 0 for legacy)\n    var chainId = (v - BN_35) / BN_2;\n    if (chainId < BN_0) {\n      chainId = BN_0;\n    }\n    tx.chainId = chainId;\n    // Signed Legacy Transaction\n    assertArgument(chainId !== BN_0 || v === BN_27 || v === BN_28, \"non-canonical legacy v\", \"v\", fields[6]);\n    tx.signature = Signature.from({\n      r: zeroPadValue(fields[7], 32),\n      s: zeroPadValue(fields[8], 32),\n      v: v\n    });\n    tx.hash = keccak256(data);\n  }\n  return tx;\n}\nfunction _serializeLegacy(tx, sig) {\n  var fields = [formatNumber(tx.nonce || 0, \"nonce\"), formatNumber(tx.gasPrice || 0, \"gasPrice\"), formatNumber(tx.gasLimit || 0, \"gasLimit\"), tx.to != null ? getAddress(tx.to) : \"0x\", formatNumber(tx.value || 0, \"value\"), tx.data || \"0x\"];\n  var chainId = BN_0;\n  if (tx.chainId != BN_0) {\n    // A chainId was provided; if non-zero we'll use EIP-155\n    chainId = getBigInt(tx.chainId, \"tx.chainId\");\n    // We have a chainId in the tx and an EIP-155 v in the signature,\n    // make sure they agree with each other\n    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n  } else if (tx.signature) {\n    // No explicit chainId, but EIP-155 have a derived implicit chainId\n    var legacy = tx.signature.legacyChainId;\n    if (legacy != null) {\n      chainId = legacy;\n    }\n  }\n  // Requesting an unsigned transaction\n  if (!sig) {\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== BN_0) {\n      fields.push(toBeArray(chainId));\n      fields.push(\"0x\");\n      fields.push(\"0x\");\n    }\n    return encodeRlp(fields);\n  }\n  // @TODO: We should probably check that tx.signature, chainId, and sig\n  //        match but that logic could break existing code, so schedule\n  //        this for the next major bump.\n  // Compute the EIP-155 v\n  var v = BigInt(27 + sig.yParity);\n  if (chainId !== BN_0) {\n    v = Signature.getChainIdV(chainId, sig.v);\n  } else if (BigInt(sig.v) !== v) {\n    assertArgument(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n  }\n  // Add the signature\n  fields.push(toBeArray(v));\n  fields.push(toBeArray(sig.r));\n  fields.push(toBeArray(sig.s));\n  return encodeRlp(fields);\n}\nfunction _parseEipSignature(tx, fields) {\n  var yParity;\n  try {\n    yParity = handleNumber(fields[0], \"yParity\");\n    if (yParity !== 0 && yParity !== 1) {\n      throw new Error(\"bad yParity\");\n    }\n  } catch (error) {\n    assertArgument(false, \"invalid yParity\", \"yParity\", fields[0]);\n  }\n  var r = zeroPadValue(fields[1], 32);\n  var s = zeroPadValue(fields[2], 32);\n  var signature = Signature.from({\n    r: r,\n    s: s,\n    yParity: yParity\n  });\n  tx.signature = signature;\n}\nfunction _parseEip1559(data) {\n  var fields = decodeRlp(getBytes(data).slice(1));\n  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), \"invalid field count for transaction type: 2\", \"data\", hexlify(data));\n  var maxPriorityFeePerGas = handleUint(fields[2], \"maxPriorityFeePerGas\");\n  var maxFeePerGas = handleUint(fields[3], \"maxFeePerGas\");\n  var tx = {\n    type: 2,\n    chainId: handleUint(fields[0], \"chainId\"),\n    nonce: handleNumber(fields[1], \"nonce\"),\n    maxPriorityFeePerGas: maxPriorityFeePerGas,\n    maxFeePerGas: maxFeePerGas,\n    gasPrice: null,\n    gasLimit: handleUint(fields[4], \"gasLimit\"),\n    to: handleAddress(fields[5]),\n    value: handleUint(fields[6], \"value\"),\n    data: hexlify(fields[7]),\n    accessList: handleAccessList(fields[8], \"accessList\")\n  };\n  // Unsigned EIP-1559 Transaction\n  if (fields.length === 9) {\n    return tx;\n  }\n  tx.hash = keccak256(data);\n  _parseEipSignature(tx, fields.slice(9));\n  return tx;\n}\nfunction _serializeEip1559(tx, sig) {\n  var fields = [formatNumber(tx.chainId || 0, \"chainId\"), formatNumber(tx.nonce || 0, \"nonce\"), formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"), formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"), formatNumber(tx.gasLimit || 0, \"gasLimit\"), tx.to != null ? getAddress(tx.to) : \"0x\", formatNumber(tx.value || 0, \"value\"), tx.data || \"0x\", formatAccessList(tx.accessList || [])];\n  if (sig) {\n    fields.push(formatNumber(sig.yParity, \"yParity\"));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n  }\n  return concat([\"0x02\", encodeRlp(fields)]);\n}\nfunction _parseEip2930(data) {\n  var fields = decodeRlp(getBytes(data).slice(1));\n  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), \"invalid field count for transaction type: 1\", \"data\", hexlify(data));\n  var tx = {\n    type: 1,\n    chainId: handleUint(fields[0], \"chainId\"),\n    nonce: handleNumber(fields[1], \"nonce\"),\n    gasPrice: handleUint(fields[2], \"gasPrice\"),\n    gasLimit: handleUint(fields[3], \"gasLimit\"),\n    to: handleAddress(fields[4]),\n    value: handleUint(fields[5], \"value\"),\n    data: hexlify(fields[6]),\n    accessList: handleAccessList(fields[7], \"accessList\")\n  };\n  // Unsigned EIP-2930 Transaction\n  if (fields.length === 8) {\n    return tx;\n  }\n  tx.hash = keccak256(data);\n  _parseEipSignature(tx, fields.slice(8));\n  return tx;\n}\nfunction _serializeEip2930(tx, sig) {\n  var fields = [formatNumber(tx.chainId || 0, \"chainId\"), formatNumber(tx.nonce || 0, \"nonce\"), formatNumber(tx.gasPrice || 0, \"gasPrice\"), formatNumber(tx.gasLimit || 0, \"gasLimit\"), tx.to != null ? getAddress(tx.to) : \"0x\", formatNumber(tx.value || 0, \"value\"), tx.data || \"0x\", formatAccessList(tx.accessList || [])];\n  if (sig) {\n    fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n  }\n  return concat([\"0x01\", encodeRlp(fields)]);\n}\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */\nexport var Transaction = /*#__PURE__*/function () {\n  _createClass(Transaction, [{\n    key: \"type\",\n    /**\n     *  The transaction type.\n     *\n     *  If null, the type will be automatically inferred based on\n     *  explicit properties.\n     */\n    get: function get() {\n      return this.#type;\n    },\n    set: function set(value) {\n      switch (value) {\n        case null:\n          this.#type = null;\n          break;\n        case 0:\n        case \"legacy\":\n          this.#type = 0;\n          break;\n        case 1:\n        case \"berlin\":\n        case \"eip-2930\":\n          this.#type = 1;\n          break;\n        case 2:\n        case \"london\":\n        case \"eip-1559\":\n          this.#type = 2;\n          break;\n        default:\n          assertArgument(false, \"unsupported transaction type\", \"type\", value);\n      }\n    }\n    /**\n     *  The name of the transaction type.\n     */\n  }, {\n    key: \"typeName\",\n    get: function get() {\n      switch (this.type) {\n        case 0:\n          return \"legacy\";\n        case 1:\n          return \"eip-2930\";\n        case 2:\n          return \"eip-1559\";\n      }\n      return null;\n    }\n    /**\n     *  The ``to`` address for the transaction or ``null`` if the\n     *  transaction is an ``init`` transaction.\n     */\n  }, {\n    key: \"to\",\n    get: function get() {\n      return this.#to;\n    },\n    set: function set(value) {\n      this.#to = value == null ? null : getAddress(value);\n    }\n    /**\n     *  The transaction nonce.\n     */\n  }, {\n    key: \"nonce\",\n    get: function get() {\n      return this.#nonce;\n    },\n    set: function set(value) {\n      this.#nonce = getNumber(value, \"value\");\n    }\n    /**\n     *  The gas limit.\n     */\n  }, {\n    key: \"gasLimit\",\n    get: function get() {\n      return this.#gasLimit;\n    },\n    set: function set(value) {\n      this.#gasLimit = getBigInt(value);\n    }\n    /**\n     *  The gas price.\n     *\n     *  On legacy networks this defines the fee that will be paid. On\n     *  EIP-1559 networks, this should be ``null``.\n     */\n  }, {\n    key: \"gasPrice\",\n    get: function get() {\n      var value = this.#gasPrice;\n      if (value == null && (this.type === 0 || this.type === 1)) {\n        return BN_0;\n      }\n      return value;\n    },\n    set: function set(value) {\n      this.#gasPrice = value == null ? null : getBigInt(value, \"gasPrice\");\n    }\n    /**\n     *  The maximum priority fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n  }, {\n    key: \"maxPriorityFeePerGas\",\n    get: function get() {\n      var value = this.#maxPriorityFeePerGas;\n      if (value == null) {\n        if (this.type === 2) {\n          return BN_0;\n        }\n        return null;\n      }\n      return value;\n    },\n    set: function set(value) {\n      this.#maxPriorityFeePerGas = value == null ? null : getBigInt(value, \"maxPriorityFeePerGas\");\n    }\n    /**\n     *  The maximum total fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n  }, {\n    key: \"maxFeePerGas\",\n    get: function get() {\n      var value = this.#maxFeePerGas;\n      if (value == null) {\n        if (this.type === 2) {\n          return BN_0;\n        }\n        return null;\n      }\n      return value;\n    },\n    set: function set(value) {\n      this.#maxFeePerGas = value == null ? null : getBigInt(value, \"maxFeePerGas\");\n    }\n    /**\n     *  The transaction data. For ``init`` transactions this is the\n     *  deployment code.\n     */\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this.#data;\n    },\n    set: function set(value) {\n      this.#data = hexlify(value);\n    }\n    /**\n     *  The amount of ether (in wei) to send in this transactions.\n     */\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.#value;\n    },\n    set: function set(value) {\n      this.#value = getBigInt(value, \"value\");\n    }\n    /**\n     *  The chain ID this transaction is valid on.\n     */\n  }, {\n    key: \"chainId\",\n    get: function get() {\n      return this.#chainId;\n    },\n    set: function set(value) {\n      this.#chainId = getBigInt(value);\n    }\n    /**\n     *  If signed, the signature for this transaction.\n     */\n  }, {\n    key: \"signature\",\n    get: function get() {\n      return this.#sig || null;\n    },\n    set: function set(value) {\n      this.#sig = value == null ? null : Signature.from(value);\n    }\n    /**\n     *  The access list.\n     *\n     *  An access list permits discounted (but pre-paid) access to\n     *  bytecode and state variable access within contract execution.\n     */\n  }, {\n    key: \"accessList\",\n    get: function get() {\n      var value = this.#accessList || null;\n      if (value == null) {\n        if (this.type === 1 || this.type === 2) {\n          return [];\n        }\n        return null;\n      }\n      return value;\n    },\n    set: function set(value) {\n      this.#accessList = value == null ? null : accessListify(value);\n    }\n    /**\n     *  Creates a new Transaction with default values.\n     */\n  }]);\n  function Transaction() {\n    _classCallCheck(this, Transaction);\n    this.#type = null;\n    this.#to = null;\n    this.#nonce = 0;\n    this.#gasLimit = BigInt(0);\n    this.#gasPrice = null;\n    this.#maxPriorityFeePerGas = null;\n    this.#maxFeePerGas = null;\n    this.#data = \"0x\";\n    this.#value = BigInt(0);\n    this.#chainId = BigInt(0);\n    this.#sig = null;\n    this.#accessList = null;\n  }\n  /**\n   *  The transaction hash, if signed. Otherwise, ``null``.\n   */\n  _createClass(Transaction, [{\n    key: \"isSigned\",\n    /**\n     *  Returns true if signed.\n     *\n     *  This provides a Type Guard that properties requiring a signed\n     *  transaction are non-null.\n     */\n    value: function isSigned() {\n      //isSigned(): this is SignedTransaction {\n      return this.signature != null;\n    }\n    /**\n     *  The serialized transaction.\n     *\n     *  This throws if the transaction is unsigned. For the pre-image,\n     *  use [[unsignedSerialized]].\n     */\n  }, {\n    key: \"inferType\",\n    /**\n     *  Return the most \"likely\" type; currently the highest\n     *  supported transaction type.\n     */\n    value: function inferType() {\n      return this.inferTypes().pop();\n    }\n    /**\n     *  Validates the explicit properties and returns a list of compatible\n     *  transaction types.\n     */\n  }, {\n    key: \"inferTypes\",\n    value: function inferTypes() {\n      // Checks that there are no conflicting properties set\n      var hasGasPrice = this.gasPrice != null;\n      var hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;\n      var hasAccessList = this.accessList != null;\n      //if (hasGasPrice && hasFee) {\n      //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n      //}\n      if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n        assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", {\n          value: this\n        });\n      }\n      //if (this.type === 2 && hasGasPrice) {\n      //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n      //}\n      assert(!hasFee || this.type !== 0 && this.type !== 1, \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", {\n        value: this\n      });\n      assert(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", {\n        value: this\n      });\n      var types = [];\n      // Explicit type\n      if (this.type != null) {\n        types.push(this.type);\n      } else {\n        if (hasFee) {\n          types.push(2);\n        } else if (hasGasPrice) {\n          types.push(1);\n          if (!hasAccessList) {\n            types.push(0);\n          }\n        } else if (hasAccessList) {\n          types.push(1);\n          types.push(2);\n        } else {\n          types.push(0);\n          types.push(1);\n          types.push(2);\n        }\n      }\n      types.sort();\n      return types;\n    }\n    /**\n     *  Returns true if this transaction is a legacy transaction (i.e.\n     *  ``type === 0``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n  }, {\n    key: \"isLegacy\",\n    value: function isLegacy() {\n      return this.type === 0;\n    }\n    /**\n     *  Returns true if this transaction is berlin hardform transaction (i.e.\n     *  ``type === 1``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n  }, {\n    key: \"isBerlin\",\n    value: function isBerlin() {\n      return this.type === 1;\n    }\n    /**\n     *  Returns true if this transaction is london hardform transaction (i.e.\n     *  ``type === 2``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n  }, {\n    key: \"isLondon\",\n    value: function isLondon() {\n      return this.type === 2;\n    }\n    /**\n     *  Create a copy of this transaciton.\n     */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return Transaction.from(this);\n    }\n    /**\n     *  Return a JSON-friendly object.\n     */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var s = function s(v) {\n        if (v == null) {\n          return null;\n        }\n        return v.toString();\n      };\n      return {\n        type: this.type,\n        to: this.to,\n        //            from: this.from,\n        data: this.data,\n        nonce: this.nonce,\n        gasLimit: s(this.gasLimit),\n        gasPrice: s(this.gasPrice),\n        maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n        maxFeePerGas: s(this.maxFeePerGas),\n        value: s(this.value),\n        chainId: s(this.chainId),\n        sig: this.signature ? this.signature.toJSON() : null,\n        accessList: this.accessList\n      };\n    }\n    /**\n     *  Create a **Transaction** from a serialized transaction or a\n     *  Transaction-like object.\n     */\n  }, {\n    key: \"hash\",\n    get: function get() {\n      if (this.signature == null) {\n        return null;\n      }\n      return keccak256(this.serialized);\n    }\n    /**\n     *  The pre-image hash of this transaction.\n     *\n     *  This is the digest that a [[Signer]] must sign to authorize\n     *  this transaction.\n     */\n  }, {\n    key: \"unsignedHash\",\n    get: function get() {\n      return keccak256(this.unsignedSerialized);\n    }\n    /**\n     *  The sending address, if signed. Otherwise, ``null``.\n     */\n  }, {\n    key: \"from\",\n    get: function get() {\n      if (this.signature == null) {\n        return null;\n      }\n      return recoverAddress(this.unsignedHash, this.signature);\n    }\n    /**\n     *  The public key of the sender, if signed. Otherwise, ``null``.\n     */\n  }, {\n    key: \"fromPublicKey\",\n    get: function get() {\n      if (this.signature == null) {\n        return null;\n      }\n      return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);\n    }\n  }, {\n    key: \"serialized\",\n    get: function get() {\n      assert(this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", {\n        operation: \".serialized\"\n      });\n      switch (this.inferType()) {\n        case 0:\n          return _serializeLegacy(this, this.signature);\n        case 1:\n          return _serializeEip2930(this, this.signature);\n        case 2:\n          return _serializeEip1559(this, this.signature);\n      }\n      assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n        operation: \".serialized\"\n      });\n    }\n    /**\n     *  The transaction pre-image.\n     *\n     *  The hash of this is the digest which needs to be signed to\n     *  authorize this transaction.\n     */\n  }, {\n    key: \"unsignedSerialized\",\n    get: function get() {\n      switch (this.inferType()) {\n        case 0:\n          return _serializeLegacy(this);\n        case 1:\n          return _serializeEip2930(this);\n        case 2:\n          return _serializeEip1559(this);\n      }\n      assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n        operation: \".unsignedSerialized\"\n      });\n    }\n  }], [{\n    key: \"from\",\n    value: function from(tx) {\n      if (tx == null) {\n        return new Transaction();\n      }\n      if (typeof tx === \"string\") {\n        var payload = getBytes(tx);\n        if (payload[0] >= 0x7f) {\n          // @TODO: > vs >= ??\n          return Transaction.from(_parseLegacy(payload));\n        }\n        switch (payload[0]) {\n          case 1:\n            return Transaction.from(_parseEip2930(payload));\n          case 2:\n            return Transaction.from(_parseEip1559(payload));\n        }\n        assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n          operation: \"from\"\n        });\n      }\n      var result = new Transaction();\n      if (tx.type != null) {\n        result.type = tx.type;\n      }\n      if (tx.to != null) {\n        result.to = tx.to;\n      }\n      if (tx.nonce != null) {\n        result.nonce = tx.nonce;\n      }\n      if (tx.gasLimit != null) {\n        result.gasLimit = tx.gasLimit;\n      }\n      if (tx.gasPrice != null) {\n        result.gasPrice = tx.gasPrice;\n      }\n      if (tx.maxPriorityFeePerGas != null) {\n        result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n      }\n      if (tx.maxFeePerGas != null) {\n        result.maxFeePerGas = tx.maxFeePerGas;\n      }\n      if (tx.data != null) {\n        result.data = tx.data;\n      }\n      if (tx.value != null) {\n        result.value = tx.value;\n      }\n      if (tx.chainId != null) {\n        result.chainId = tx.chainId;\n      }\n      if (tx.signature != null) {\n        result.signature = Signature.from(tx.signature);\n      }\n      if (tx.accessList != null) {\n        result.accessList = tx.accessList;\n      }\n      if (tx.hash != null) {\n        assertArgument(result.isSigned(), \"unsigned transaction cannot define hash\", \"tx\", tx);\n        assertArgument(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n      }\n      if (tx.from != null) {\n        assertArgument(result.isSigned(), \"unsigned transaction cannot define from\", \"tx\", tx);\n        assertArgument(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n      }\n      return result;\n    }\n  }]);\n  return Transaction;\n}();","map":null,"metadata":{},"sourceType":"module"}