{"ast":null,"code":"import { getAddress } from \"../address/index.js\";\nimport { keccak256 as _keccak256, sha256 as _sha256 } from \"../crypto/index.js\";\nimport { concat, dataLength, getBytes, hexlify, toBeArray, toTwos, toUtf8Bytes, zeroPadBytes, zeroPadValue, assertArgument } from \"../utils/index.js\";\nvar regexBytes = new RegExp(\"^bytes([0-9]+)$\");\nvar regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\nvar regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\nfunction _pack(type, value, isArray) {\n  switch (type) {\n    case \"address\":\n      if (isArray) {\n        return getBytes(zeroPadValue(value, 32));\n      }\n      return getBytes(getAddress(value));\n    case \"string\":\n      return toUtf8Bytes(value);\n    case \"bytes\":\n      return getBytes(value);\n    case \"bool\":\n      value = !!value ? \"0x01\" : \"0x00\";\n      if (isArray) {\n        return getBytes(zeroPadValue(value, 32));\n      }\n      return getBytes(value);\n  }\n  var match = type.match(regexNumber);\n  if (match) {\n    var signed = match[1] === \"int\";\n    var size = parseInt(match[2] || \"256\");\n    assertArgument((!match[2] || match[2] === String(size)) && size % 8 === 0 && size !== 0 && size <= 256, \"invalid number type\", \"type\", type);\n    if (isArray) {\n      size = 256;\n    }\n    if (signed) {\n      value = toTwos(value, size);\n    }\n    return getBytes(zeroPadValue(toBeArray(value), size / 8));\n  }\n  match = type.match(regexBytes);\n  if (match) {\n    var _size = parseInt(match[1]);\n    assertArgument(String(_size) === match[1] && _size !== 0 && _size <= 32, \"invalid bytes type\", \"type\", type);\n    assertArgument(dataLength(value) === _size, \"invalid value for \".concat(type), \"value\", value);\n    if (isArray) {\n      return getBytes(zeroPadBytes(value, 32));\n    }\n    return value;\n  }\n  match = type.match(regexArray);\n  if (match && Array.isArray(value)) {\n    var baseType = match[1];\n    var count = parseInt(match[2] || String(value.length));\n    assertArgument(count === value.length, \"invalid array length for \".concat(type), \"value\", value);\n    var result = [];\n    value.forEach(function (value) {\n      result.push(_pack(baseType, value, true));\n    });\n    return getBytes(concat(result));\n  }\n  assertArgument(false, \"invalid type\", \"type\", type);\n}\n// @TODO: Array Enum\n/**\n *   Computes the [[link-solc-packed]] representation of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPacked([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */\nexport function solidityPacked(types, values) {\n  assertArgument(types.length === values.length, \"wrong number of values; expected ${ types.length }\", \"values\", values);\n  var tight = [];\n  types.forEach(function (type, index) {\n    tight.push(_pack(type, values[index]));\n  });\n  return hexlify(concat(tight));\n}\n/**\n *   Computes the [[link-solc-packed]] [[keccak256]] hash of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPackedKeccak256([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */\nexport function solidityPackedKeccak256(types, values) {\n  return _keccak256(solidityPacked(types, values));\n}\n/**\n *   Computes the [[link-solc-packed]] [[sha256]] hash of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPackedSha256([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */\nexport function solidityPackedSha256(types, values) {\n  return _sha256(solidityPacked(types, values));\n}","map":null,"metadata":{},"sourceType":"module"}